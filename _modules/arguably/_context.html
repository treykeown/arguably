<!doctype html>
<html class="no-js" lang="en">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><link rel="index" title="Index" href="../../genindex.html" /><link rel="search" title="Search" href="../../search.html" />

    <!-- Generated with Sphinx 7.0.1 and Furo 2023.05.20 -->
        <title>arguably._context - arguably 1.1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo.css?digest=e6660623a769aa55fea372102b9bf3151b292993" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../index.html"><div class="brand">arguably 1.1.0 documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../index.html">
  
  
  <span class="sidebar-brand-text">arguably 1.1.0 documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  
</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <h1>Source code for arguably._context</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span> <span class="nn">argparse</span>
<span class="kn">import</span> <span class="nn">enum</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">contextmanager</span>
<span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">TextIO</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Type</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Iterator</span>

<span class="kn">from</span> <span class="nn">docstring_parser</span> <span class="kn">import</span> <span class="n">parse</span> <span class="k">as</span> <span class="n">docparse</span>

<span class="kn">from</span> <span class="nn">._argparse_extensions</span> <span class="kn">import</span> <span class="n">HelpFormatter</span><span class="p">,</span> <span class="n">FlagAction</span><span class="p">,</span> <span class="n">ArgumentParser</span>
<span class="kn">from</span> <span class="nn">._commands</span> <span class="kn">import</span> <span class="n">CommandDecoratorInfo</span><span class="p">,</span> <span class="n">SubtypeDecoratorInfo</span><span class="p">,</span> <span class="n">Command</span><span class="p">,</span> <span class="n">CommandArg</span><span class="p">,</span> <span class="n">InputMethod</span>
<span class="kn">from</span> <span class="nn">._modifiers</span> <span class="kn">import</span> <span class="n">TupleModifier</span><span class="p">,</span> <span class="n">ListModifier</span>
<span class="kn">from</span> <span class="nn">._util</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">warn</span><span class="p">,</span>
    <span class="n">logger</span><span class="p">,</span>
    <span class="n">log_args</span><span class="p">,</span>
    <span class="n">ArguablyException</span><span class="p">,</span>
    <span class="n">normalize_name</span><span class="p">,</span>
    <span class="n">NoDefault</span><span class="p">,</span>
    <span class="n">get_type_hints</span><span class="p">,</span>
    <span class="n">find_alias</span><span class="p">,</span>
    <span class="n">info_for_flags</span><span class="p">,</span>
    <span class="n">get_ancestors</span><span class="p">,</span>
    <span class="n">get_parser_name</span><span class="p">,</span>
<span class="p">)</span>


<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">_ContextOptions</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Options for arguably</span>

<span class="sd">    :ivar name: Name of the script/program. Defaults to the filename or module name (depending on invocation method).</span>

<span class="sd">    :ivar call_ancestors: Normally false. If true, `git init` will first call `git()`, then `git__init()`. Calls all</span>
<span class="sd">        members of the hierarchy. This allows parents to handle options. Parents can determine if they are actually the</span>
<span class="sd">        target command (instead of being called through the heirarchy) through the `is_target()` method.</span>
<span class="sd">    :ivar always_subcommand: Normally false. If true, will force a subcommand interface to be used, even if there&#39;s only</span>
<span class="sd">        one command.</span>
<span class="sd">    :ivar auto_alias_cmds: Normally false. If true, will automatically create a short alias for every command. See</span>
<span class="sd">        `_find_alias` for implementation.</span>
<span class="sd">    :ivar auto_alias_params: Normally false. If true, will automatically create a short alias for every parameter</span>
<span class="sd">        (example: `-v` for `--verbose`). See `_find_alias` for implementation.</span>
<span class="sd">    :ivar version_flag: Normally false. If true, will set up version printing using `__version__` and add options to</span>
<span class="sd">        the root parser.</span>

<span class="sd">    :ivar show_defaults: Show default values for optional arguments.</span>
<span class="sd">    :ivar show_types: Show the type of each argument.</span>
<span class="sd">    :ivar command_metavar: Allows you to change how the subcommand placeholder appears in the usage string.</span>
<span class="sd">    :ivar max_description_offset: The maximum number of columns before argument descriptions are printed. Equivalent to</span>
<span class="sd">        `max_help_position` in argparse.</span>
<span class="sd">    :ivar max_width: The total maximum width of text to be displayed in the terminal. Equivalent to `width` in argparse.</span>
<span class="sd">    :ivar output: Where argparse output should be written - can write to a file, stderr, or anything similar.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>

    <span class="c1"># Behavior options</span>
    <span class="n">call_ancestors</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="n">always_subcommand</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="n">auto_alias_cmds</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="n">auto_alias_params</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="n">version_flag</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span>

    <span class="c1"># Formatting options</span>
    <span class="n">show_defaults</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="n">show_types</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="n">command_metavar</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">max_description_offset</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">max_width</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">output</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TextIO</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># When running as a module, show the script name as the module path.</span>
        <span class="c1"># Otherwise, use default argparse behavior</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="kn">import</span> <span class="nn">importlib.util</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">find_spec</span><span class="p">(</span><span class="s2">&quot;__main__&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">name</span>  <span class="c1"># type: ignore[union-attr]</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>


<span class="k">class</span> <span class="nc">_Context</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Singleton, used for storing arguably state.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># These are `None` right now, they&#39;re set during `run()`. No methods making use of them are called before then.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_options</span><span class="p">:</span> <span class="n">_ContextOptions</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: ignore[assignment]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_extra_argparser_options</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: ignore[assignment]</span>

        <span class="c1"># Info for all invocations of `@arguably.command`</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_command_decorator_info</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">CommandDecoratorInfo</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

        <span class="c1"># Info for all invocations of `@arguably.subtype`</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_subtype_init_info</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">SubtypeDecoratorInfo</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

        <span class="c1"># Stores mapping from normalized names for an enum type to an enum value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_enum_mapping</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Type</span><span class="p">[</span><span class="n">enum</span><span class="o">.</span><span class="n">Enum</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">enum</span><span class="o">.</span><span class="n">Enum</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="c1"># Stores which flag arguments have had their default value cleared</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_enum_flag_default_cleared</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="c1"># Are we currently calling the targeted command (or just an ancestor?)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_calling_target</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Used for handling `error()`, keeps a reference to the parser for the current command</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_parser</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># These are really only set and used in the run() method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_commands</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Command</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_command_aliases</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parsers</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_subparsers</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>  <span class="c1"># type: ignore[misc]</span>

    <span class="k">def</span> <span class="nf">add_command</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Invoked by `@arguably.command`, saves info about a command to include when the parser is set up.&quot;&quot;&quot;</span>
        <span class="n">info</span> <span class="o">=</span> <span class="n">CommandDecoratorInfo</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_command_decorator_info</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_subtype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Invoked by `@arguably.subtype`, saves info about a how to construct a type.&quot;&quot;&quot;</span>
        <span class="n">type_</span> <span class="o">=</span> <span class="n">SubtypeDecoratorInfo</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_subtype_init_info</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">type_</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">find_subtype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func_arg_type</span><span class="p">:</span> <span class="nb">type</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">SubtypeDecoratorInfo</span><span class="p">]:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">bi</span> <span class="k">for</span> <span class="n">bi</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subtype_init_info</span> <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">bi</span><span class="o">.</span><span class="n">type_</span><span class="p">,</span> <span class="n">func_arg_type</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">is_calling_target</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Aliased by `arguably.is_target`. Only useful when `invoke_ancestors=True`, it lets a command know whether</span>
<span class="sd">        it&#39;s the main targeted command or just an ancestor of the targeted command.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_calling_target</span>

    <span class="k">def</span> <span class="nf">check_and_set_enum_flag_default_status</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">:</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">,</span> <span class="n">cli_arg_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">parser</span><span class="p">,</span> <span class="n">cli_arg_name</span><span class="p">)</span>
        <span class="n">present</span> <span class="o">=</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_enum_flag_default_cleared</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_enum_flag_default_cleared</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">present</span>

    <span class="k">def</span> <span class="nf">_formatter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prog</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HelpFormatter</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;HelpFormatter for argparse, hooks up our max_name_width and max_width options.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">HelpFormatter</span><span class="p">(</span>
            <span class="n">prog</span><span class="p">,</span> <span class="n">max_help_position</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_options</span><span class="o">.</span><span class="n">max_description_offset</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_options</span><span class="o">.</span><span class="n">max_width</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_process_decorator_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">info</span><span class="p">:</span> <span class="n">CommandDecoratorInfo</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Command</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Takes the decorator info and return a processed command&quot;&quot;&quot;</span>

        <span class="n">processed_name</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">name</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">function</span><span class="o">.</span><span class="fm">__init__</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">info</span><span class="o">.</span><span class="n">function</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span> <span class="k">else</span> <span class="n">info</span><span class="o">.</span><span class="n">function</span>  <span class="c1"># type: ignore[misc]</span>

        <span class="c1"># Get the description from the docstring</span>
        <span class="k">if</span> <span class="n">func</span><span class="o">.</span><span class="vm">__doc__</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">docs</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">processed_description</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">docs</span> <span class="o">=</span> <span class="n">docparse</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
            <span class="n">processed_description</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span> <span class="k">if</span> <span class="n">docs</span><span class="o">.</span><span class="n">short_description</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">docs</span><span class="o">.</span><span class="n">short_description</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">hints</span> <span class="o">=</span> <span class="n">get_type_hints</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">include_extras</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">NameError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">hints</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unable to resolve type hints for function </span><span class="si">{</span><span class="n">processed_name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>

        <span class="c1"># Will be filled in as we loop over all parameters</span>
        <span class="n">processed_args</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">CommandArg</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">used_arg_aliases</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

        <span class="c1"># Iterate over all parameters</span>
        <span class="k">for</span> <span class="n">func_arg_name</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">info</span><span class="o">.</span><span class="n">function</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">cli_arg_name</span> <span class="o">=</span> <span class="n">normalize_name</span><span class="p">(</span><span class="n">func_arg_name</span><span class="p">,</span> <span class="n">spaces</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">arg_default</span> <span class="o">=</span> <span class="n">NoDefault</span> <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="n">param</span><span class="o">.</span><span class="n">empty</span> <span class="k">else</span> <span class="n">param</span><span class="o">.</span><span class="n">default</span>

            <span class="c1"># Handle variadic arguments</span>
            <span class="n">is_variadic</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">kind</span> <span class="ow">is</span> <span class="n">param</span><span class="o">.</span><span class="n">VAR_KEYWORD</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ArguablyException</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;`</span><span class="si">{</span><span class="n">processed_name</span><span class="si">}</span><span class="s2">` is using **kwargs, which is not supported&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">kind</span> <span class="ow">is</span> <span class="n">param</span><span class="o">.</span><span class="n">VAR_POSITIONAL</span><span class="p">:</span>
                <span class="n">is_variadic</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># Get the type and normalize it</span>
            <span class="n">arg_value_type</span><span class="p">,</span> <span class="n">modifiers</span> <span class="o">=</span> <span class="n">CommandArg</span><span class="o">.</span><span class="n">normalize_type</span><span class="p">(</span><span class="n">processed_name</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">hints</span><span class="p">)</span>
            <span class="n">tuple_modifiers</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">modifiers</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">TupleModifier</span><span class="p">)]</span>
            <span class="n">expected_metavars</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tuple_modifiers</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">tuple_modifiers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="n">expected_metavars</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tuple_modifiers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tuple_arg</span><span class="p">)</span>

            <span class="c1"># Get the description</span>
            <span class="n">arg_description</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="k">if</span> <span class="n">docs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">docs</span><span class="o">.</span><span class="n">params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ds_matches</span> <span class="o">=</span> <span class="p">[</span><span class="n">ds_p</span> <span class="k">for</span> <span class="n">ds_p</span> <span class="ow">in</span> <span class="n">docs</span><span class="o">.</span><span class="n">params</span> <span class="k">if</span> <span class="n">ds_p</span><span class="o">.</span><span class="n">arg_name</span> <span class="o">==</span> <span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ds_matches</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">ArguablyException</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Function parameter `</span><span class="si">{</span><span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">` in &quot;</span> <span class="sa">f</span><span class="s2">&quot;`</span><span class="si">{</span><span class="n">processed_name</span><span class="si">}</span><span class="s2">` has multiple docstring entries.&quot;</span>
                    <span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ds_matches</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">ds_info</span> <span class="o">=</span> <span class="n">ds_matches</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">arg_description</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span> <span class="k">if</span> <span class="n">ds_info</span><span class="o">.</span><span class="n">description</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">ds_info</span><span class="o">.</span><span class="n">description</span>

            <span class="c1"># Extract the alias</span>
            <span class="n">arg_alias</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">alias_match</span> <span class="o">:=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;^\[-([a-zA-Z0-9])] &quot;</span><span class="p">,</span> <span class="n">arg_description</span><span class="p">):</span>
                <span class="n">arg_description</span> <span class="o">=</span> <span class="n">arg_description</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">alias_match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="p">:]</span>
                <span class="n">arg_alias</span> <span class="o">=</span> <span class="n">alias_match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

            <span class="c1"># Generate the alias if required and there isn&#39;t one</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_options</span><span class="o">.</span><span class="n">auto_alias_params</span> <span class="ow">and</span> <span class="n">arg_alias</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">arg_alias</span> <span class="o">=</span> <span class="n">find_alias</span><span class="p">(</span><span class="n">used_arg_aliases</span><span class="p">,</span> <span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">arg_alias</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">used_arg_aliases</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg_alias</span><span class="p">)</span>

            <span class="c1"># Extract the metavars</span>
            <span class="n">metavars</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">metavar_split</span> <span class="o">:=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\{((?:[a-zA-Z0-9_-]+(?:, *)*)+)}&quot;</span><span class="p">,</span> <span class="n">arg_description</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">metavar_split</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="c1"># format would be: [&#39;pre-metavar&#39;, &#39;METAVAR&#39;, &#39;post-metavar&#39;]</span>
                    <span class="n">match_items</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">metavar_split</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)]</span>
                    <span class="k">if</span> <span class="n">is_variadic</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">match_items</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="n">ArguablyException</span><span class="p">(</span>
                                <span class="sa">f</span><span class="s2">&quot;Function parameter `</span><span class="si">{</span><span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">` in `</span><span class="si">{</span><span class="n">processed_name</span><span class="si">}</span><span class="s2">` should only have one item in &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;its metavar descriptor, but found </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">match_items</span><span class="p">)</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">match_items</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
                            <span class="p">)</span>
                    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">match_items</span><span class="p">)</span> <span class="o">!=</span> <span class="n">expected_metavars</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">match_items</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">match_items</span> <span class="o">*=</span> <span class="n">expected_metavars</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="n">ArguablyException</span><span class="p">(</span>
                                <span class="sa">f</span><span class="s2">&quot;Function parameter `</span><span class="si">{</span><span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">` in `</span><span class="si">{</span><span class="n">processed_name</span><span class="si">}</span><span class="s2">` takes </span><span class="si">{</span><span class="n">expected_metavars</span><span class="si">}</span><span class="s2"> &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;items, but metavar descriptor has </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">match_items</span><span class="p">)</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">match_items</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
                            <span class="p">)</span>
                    <span class="n">metavars</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">match_items</span><span class="p">]</span>
                    <span class="n">arg_description</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">metavar_split</span><span class="p">)</span>  <span class="c1"># Strips { and } from metavars for description</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">metavar_split</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">ArguablyException</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Function parameter `</span><span class="si">{</span><span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">` in `</span><span class="si">{</span><span class="n">processed_name</span><span class="si">}</span><span class="s2">` has multiple metavar sequences - &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;these are denoted like </span><span class="se">{{</span><span class="s2">A, B, C</span><span class="se">}}</span><span class="s2">. There should be only one.&quot;</span>
                    <span class="p">)</span>

            <span class="c1"># What kind of argument is this? Is it required-positional, optional-positional, or an option?</span>
            <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">param</span><span class="o">.</span><span class="n">KEYWORD_ONLY</span><span class="p">:</span>
                <span class="n">input_method</span> <span class="o">=</span> <span class="n">InputMethod</span><span class="o">.</span><span class="n">OPTION</span>
            <span class="k">elif</span> <span class="n">arg_default</span> <span class="ow">is</span> <span class="n">NoDefault</span><span class="p">:</span>
                <span class="n">input_method</span> <span class="o">=</span> <span class="n">InputMethod</span><span class="o">.</span><span class="n">REQUIRED_POSITIONAL</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">input_method</span> <span class="o">=</span> <span class="n">InputMethod</span><span class="o">.</span><span class="n">OPTIONAL_POSITIONAL</span>

            <span class="c1"># Check modifiers</span>
            <span class="k">for</span> <span class="n">modifier</span> <span class="ow">in</span> <span class="n">modifiers</span><span class="p">:</span>
                <span class="n">modifier</span><span class="o">.</span><span class="n">check_valid</span><span class="p">(</span><span class="n">arg_value_type</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">processed_name</span><span class="p">)</span>

            <span class="c1"># Finished processing this arg</span>
            <span class="n">processed_args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">CommandArg</span><span class="p">(</span>
                    <span class="n">func_arg_name</span><span class="p">,</span>
                    <span class="n">cli_arg_name</span><span class="p">,</span>
                    <span class="n">input_method</span><span class="p">,</span>
                    <span class="n">is_variadic</span><span class="p">,</span>
                    <span class="n">arg_value_type</span><span class="p">,</span>
                    <span class="n">arg_description</span><span class="p">,</span>
                    <span class="n">arg_alias</span><span class="p">,</span>
                    <span class="n">metavars</span><span class="p">,</span>
                    <span class="n">arg_default</span><span class="p">,</span>
                    <span class="n">modifiers</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># Return the processed command</span>
        <span class="k">return</span> <span class="n">Command</span><span class="p">(</span>
            <span class="n">info</span><span class="o">.</span><span class="n">function</span><span class="p">,</span>
            <span class="n">processed_name</span><span class="p">,</span>
            <span class="n">processed_args</span><span class="p">,</span>
            <span class="n">processed_description</span><span class="p">,</span>
            <span class="n">info</span><span class="o">.</span><span class="n">alias</span><span class="p">,</span>
            <span class="n">info</span><span class="o">.</span><span class="n">help</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_up_enum</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">enum_type</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">enum</span><span class="o">.</span><span class="n">Enum</span><span class="p">],</span> <span class="n">members</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">enum</span><span class="o">.</span><span class="n">Enum</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">enum</span><span class="o">.</span><span class="n">Enum</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">enum_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_enum_mapping</span><span class="p">:</span>
            <span class="n">enum_name_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">enum</span><span class="o">.</span><span class="n">Enum</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_enum_mapping</span><span class="p">[</span><span class="n">enum_type</span><span class="p">]</span> <span class="o">=</span> <span class="n">enum_name_dict</span>

            <span class="k">for</span> <span class="n">enum_item</span> <span class="ow">in</span> <span class="n">enum_type</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">members</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">enum_item</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">members</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">enum_name</span> <span class="o">=</span> <span class="n">normalize_name</span><span class="p">(</span><span class="n">enum_item</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">spaces</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">enum_name</span> <span class="ow">in</span> <span class="n">enum_name_dict</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">ArguablyException</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Normalized name </span><span class="si">{</span><span class="n">enum_name</span><span class="si">}</span><span class="s2"> already taken for enum </span><span class="si">{</span><span class="n">enum_type</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> by &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">enum_name_dict</span><span class="p">[</span><span class="n">enum_name</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                <span class="n">enum_name_dict</span><span class="p">[</span><span class="n">enum_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">enum_item</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_enum_mapping</span><span class="p">[</span><span class="n">enum_type</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">get_enum_mapping</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">enum_type</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">enum</span><span class="o">.</span><span class="n">Enum</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">enum</span><span class="o">.</span><span class="n">Enum</span><span class="p">]:</span>
        <span class="k">assert</span> <span class="n">enum_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_enum_mapping</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_enum_mapping</span><span class="p">[</span><span class="n">enum_type</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_set_up_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cmd</span><span class="p">:</span> <span class="n">Command</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adds all arguments to the parser for a given command&quot;&quot;&quot;</span>

        <span class="n">parser</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parsers</span><span class="p">[</span><span class="n">cmd</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">arg_</span> <span class="ow">in</span> <span class="n">cmd</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">arg_</span><span class="o">.</span><span class="n">input_method</span><span class="o">.</span><span class="n">is_positional</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">arg_</span><span class="o">.</span><span class="n">func_arg_name</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_options</span><span class="o">.</span><span class="n">command_metavar</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">ArguablyException</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Function argument `</span><span class="si">{</span><span class="n">arg_</span><span class="o">.</span><span class="n">func_arg_name</span><span class="si">}</span><span class="s2">` in `</span><span class="si">{</span><span class="n">cmd</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">` is named the same as &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;`command_metavar`. Either change the parameter name or set the `command_metavar` option to &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;something other than `</span><span class="si">{</span><span class="n">arg_</span><span class="o">.</span><span class="n">func_arg_name</span><span class="si">}</span><span class="s2">` when calling arguably.run()&quot;</span>
                    <span class="p">)</span>
            <span class="c1"># Short-circuit, different path for enum.Flag. We add multiple options, one for each flag entry</span>
            <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">arg_</span><span class="o">.</span><span class="n">arg_value_type</span><span class="p">,</span> <span class="n">enum</span><span class="o">.</span><span class="n">Flag</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">arg_</span><span class="o">.</span><span class="n">input_method</span><span class="o">.</span><span class="n">is_positional</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">ArguablyException</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Function argument `</span><span class="si">{</span><span class="n">arg_</span><span class="o">.</span><span class="n">func_arg_name</span><span class="si">}</span><span class="s2">` in `</span><span class="si">{</span><span class="n">cmd</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">` is both positional and an enum.Flag.&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot; Positional enum flags are unsupported, since they are turned into options.&quot;</span>
                    <span class="p">)</span>
                <span class="k">if</span> <span class="n">arg_</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="n">NoDefault</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">ArguablyException</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Function argument `</span><span class="si">{</span><span class="n">arg_</span><span class="o">.</span><span class="n">func_arg_name</span><span class="si">}</span><span class="s2">` in `</span><span class="si">{</span><span class="n">cmd</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">` is an enum.Flag. Due to &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;implementation limitations, all enum.Flag parameters must have a default value.&quot;</span>
                    <span class="p">)</span>
                <span class="n">parser</span><span class="o">.</span><span class="n">set_defaults</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">arg_</span><span class="o">.</span><span class="n">cli_arg_name</span><span class="p">:</span> <span class="n">arg_</span><span class="o">.</span><span class="n">default</span><span class="p">})</span>
                <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">info_for_flags</span><span class="p">(</span><span class="n">arg_</span><span class="o">.</span><span class="n">cli_arg_name</span><span class="p">,</span> <span class="n">arg_</span><span class="o">.</span><span class="n">arg_value_type</span><span class="p">):</span>
                    <span class="n">argspec</span> <span class="o">=</span> <span class="n">log_args</span><span class="p">(</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span>
                        <span class="sa">f</span><span class="s2">&quot;Parser(</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">get_parser_name</span><span class="p">(</span><span class="n">parser</span><span class="o">.</span><span class="n">prog</span><span class="p">))</span><span class="si">}</span><span class="s2">).&quot;</span><span class="p">,</span>
                        <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                        <span class="c1"># Args for the call are below:</span>
                        <span class="o">*</span><span class="n">entry</span><span class="o">.</span><span class="n">option</span><span class="p">,</span>
                        <span class="n">action</span><span class="o">=</span><span class="n">FlagAction</span><span class="p">,</span>
                        <span class="n">const</span><span class="o">=</span><span class="n">entry</span><span class="p">,</span>
                        <span class="n">nargs</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="n">entry</span><span class="o">.</span><span class="n">description</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="o">*</span><span class="n">argspec</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">argspec</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="c1"># Optional kwargs for parser.add_argument</span>
            <span class="n">add_arg_kwargs</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="n">arg_</span><span class="o">.</span><span class="n">arg_value_type</span><span class="p">)</span>

            <span class="n">arg_description</span> <span class="o">=</span> <span class="n">arg_</span><span class="o">.</span><span class="n">description</span>
            <span class="n">description_extras</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># Show arg type?</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_options</span><span class="o">.</span><span class="n">show_types</span><span class="p">:</span>
                <span class="n">type_name</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                <span class="n">list_modifiers</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">arg_</span><span class="o">.</span><span class="n">modifiers</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">ListModifier</span><span class="p">)]</span>
                <span class="n">tuple_modifiers</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">arg_</span><span class="o">.</span><span class="n">modifiers</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">TupleModifier</span><span class="p">)]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tuple_modifiers</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">tuple_modifiers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
                    <span class="n">type_name</span> <span class="o">=</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="vm">__name__</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tuple_modifiers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tuple_arg</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">type_name</span> <span class="o">=</span> <span class="n">arg_</span><span class="o">.</span><span class="n">arg_value_type</span><span class="o">.</span><span class="vm">__name__</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_modifiers</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_modifiers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
                    <span class="n">type_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;list[</span><span class="si">{</span><span class="n">type_name</span><span class="si">}</span><span class="s2">]&quot;</span>
                <span class="n">description_extras</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;type: </span><span class="si">{</span><span class="n">type_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># `default` value?</span>
            <span class="k">if</span> <span class="n">arg_</span><span class="o">.</span><span class="n">input_method</span><span class="o">.</span><span class="n">is_optional</span> <span class="ow">and</span> <span class="n">arg_</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">NoDefault</span><span class="p">:</span>
                <span class="n">add_arg_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="n">arg_</span><span class="o">.</span><span class="n">default</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_options</span><span class="o">.</span><span class="n">show_defaults</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg_</span><span class="o">.</span><span class="n">default</span><span class="p">,</span> <span class="n">enum</span><span class="o">.</span><span class="n">Enum</span><span class="p">):</span>
                        <span class="n">description_extras</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;default: </span><span class="si">{</span><span class="n">normalize_name</span><span class="p">(</span><span class="n">arg_</span><span class="o">.</span><span class="n">default</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">spaces</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg_</span><span class="o">.</span><span class="n">default</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                        <span class="n">str_default</span> <span class="o">=</span> <span class="n">arg_</span><span class="o">.</span><span class="n">default</span>
                        <span class="c1"># Use the string repr if it contains spaces, contains a newline, or is zero-length</span>
                        <span class="k">if</span> <span class="p">(</span><span class="s2">&quot; &quot;</span> <span class="ow">in</span> <span class="n">str_default</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="ow">in</span> <span class="n">str_default</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">str_default</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                            <span class="n">str_default</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="n">str_default</span><span class="p">)</span>
                        <span class="n">description_extras</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;default: </span><span class="si">{</span><span class="n">str_default</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">description_extras</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;default: </span><span class="si">{</span><span class="n">arg_</span><span class="o">.</span><span class="n">default</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># Number of arguments `nargs`?</span>
            <span class="k">if</span> <span class="n">arg_</span><span class="o">.</span><span class="n">is_variadic</span><span class="p">:</span>
                <span class="n">add_arg_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">nargs</span><span class="o">=</span><span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="nb">list</span><span class="p">())</span>
            <span class="k">elif</span> <span class="n">arg_</span><span class="o">.</span><span class="n">input_method</span> <span class="ow">is</span> <span class="n">InputMethod</span><span class="o">.</span><span class="n">OPTIONAL_POSITIONAL</span><span class="p">:</span>
                <span class="n">add_arg_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">nargs</span><span class="o">=</span><span class="s2">&quot;?&quot;</span><span class="p">)</span>

            <span class="c1"># Any specified `metavar`s?</span>
            <span class="k">if</span> <span class="n">arg_</span><span class="o">.</span><span class="n">metavars</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arg_</span><span class="o">.</span><span class="n">metavars</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">add_arg_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">metavar</span><span class="o">=</span><span class="n">arg_</span><span class="o">.</span><span class="n">metavars</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">add_arg_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">metavar</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">arg_</span><span class="o">.</span><span class="n">metavars</span><span class="p">))</span>

            <span class="c1"># Possible choices `choices`?</span>
            <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">arg_</span><span class="o">.</span><span class="n">arg_value_type</span><span class="p">,</span> <span class="n">enum</span><span class="o">.</span><span class="n">Enum</span><span class="p">):</span>
                <span class="n">mapping</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_up_enum</span><span class="p">(</span><span class="n">arg_</span><span class="o">.</span><span class="n">arg_value_type</span><span class="p">)</span>
                <span class="n">add_arg_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">choices</span><span class="o">=</span><span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">mapping</span><span class="p">])</span>

            <span class="n">cli_arg_names</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">arg_</span><span class="o">.</span><span class="n">cli_arg_name</span><span class="p">,)</span>

            <span class="c1"># Special handling for optional arguments</span>
            <span class="k">if</span> <span class="n">arg_</span><span class="o">.</span><span class="n">input_method</span> <span class="ow">is</span> <span class="n">InputMethod</span><span class="o">.</span><span class="n">OPTION</span><span class="p">:</span>
                <span class="n">cli_arg_names</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;--</span><span class="si">{</span><span class="n">arg_</span><span class="o">.</span><span class="n">cli_arg_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,)</span> <span class="k">if</span> <span class="n">arg_</span><span class="o">.</span><span class="n">alias</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;-</span><span class="si">{</span><span class="n">arg_</span><span class="o">.</span><span class="n">alias</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;--</span><span class="si">{</span><span class="n">arg_</span><span class="o">.</span><span class="n">cli_arg_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="p">)</span>

            <span class="c1"># `bool` should be flags</span>
            <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">arg_</span><span class="o">.</span><span class="n">arg_value_type</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">arg_</span><span class="o">.</span><span class="n">input_method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">InputMethod</span><span class="o">.</span><span class="n">OPTION</span> <span class="ow">or</span> <span class="n">arg_</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="n">NoDefault</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">ArguablyException</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Function parameter `</span><span class="si">{</span><span class="n">arg_</span><span class="o">.</span><span class="n">func_arg_name</span><span class="si">}</span><span class="s2">` in `</span><span class="si">{</span><span class="n">cmd</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">` is a `bool`. Boolean parameters &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;must have a default value and be an optional, not a positional, argument.&quot;</span>
                    <span class="p">)</span>
                <span class="c1"># Use `store_true` or `store_false` for bools</span>
                <span class="n">add_arg_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">action</span><span class="o">=</span><span class="s2">&quot;store_true&quot;</span> <span class="k">if</span> <span class="n">arg_</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="kc">False</span> <span class="k">else</span> <span class="s2">&quot;store_false&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="s2">&quot;type&quot;</span> <span class="ow">in</span> <span class="n">add_arg_kwargs</span><span class="p">:</span>
                    <span class="k">del</span> <span class="n">add_arg_kwargs</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span>

            <span class="c1"># Set the help description</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">description_extras</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arg_description</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">arg_description</span> <span class="o">+=</span> <span class="s2">&quot; &quot;</span>
                <span class="n">arg_description</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">description_extras</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="n">add_arg_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">help</span><span class="o">=</span><span class="n">arg_description</span><span class="p">)</span>

            <span class="c1"># Run modifiers for this arg</span>
            <span class="k">for</span> <span class="n">modifier</span> <span class="ow">in</span> <span class="n">arg_</span><span class="o">.</span><span class="n">modifiers</span><span class="p">:</span>
                <span class="n">modifier</span><span class="o">.</span><span class="n">modify_arg_dict</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">arg_</span><span class="p">,</span> <span class="n">add_arg_kwargs</span><span class="p">)</span>

            <span class="c1"># Add the argument to the parser</span>
            <span class="n">argspec</span> <span class="o">=</span> <span class="n">log_args</span><span class="p">(</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span>
                <span class="sa">f</span><span class="s2">&quot;Parser(</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">get_parser_name</span><span class="p">(</span><span class="n">parser</span><span class="o">.</span><span class="n">prog</span><span class="p">))</span><span class="si">}</span><span class="s2">).&quot;</span><span class="p">,</span>
                <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                <span class="c1"># Args for the call are below:</span>
                <span class="o">*</span><span class="n">cli_arg_names</span><span class="p">,</span>
                <span class="o">**</span><span class="n">add_arg_kwargs</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="o">*</span><span class="n">argspec</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">argspec</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_build_subparser_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">command_decorator_info</span><span class="p">:</span> <span class="n">CommandDecoratorInfo</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Builds up the subparser tree for a given `_CommandDecoratorInfo`. Inserts dummy entries to `self._parsers`</span>
<span class="sd">        and `self._commands` if necessary. Returns the name of the parent for this command.&quot;&quot;&quot;</span>

        <span class="n">prev_ancestor</span> <span class="o">=</span> <span class="s2">&quot;__root__&quot;</span>

        <span class="c1"># Create tree of parsers and subparsers for ancestors</span>
        <span class="n">ancestor_names</span> <span class="o">=</span> <span class="n">get_ancestors</span><span class="p">(</span><span class="n">command_decorator_info</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ancestor</span> <span class="ow">in</span> <span class="n">ancestor_names</span><span class="p">:</span>
            <span class="n">required_subparser</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">ancestor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_commands</span><span class="p">:</span>
                <span class="c1"># Dummy command - this ancestor doesn&#39;t have a function of its own, it&#39;s just a path.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_commands</span><span class="p">[</span><span class="n">ancestor</span><span class="p">]</span> <span class="o">=</span> <span class="n">Command</span><span class="p">(</span><span class="k">lambda</span> <span class="o">*</span><span class="n">_</span><span class="p">,</span> <span class="o">**</span><span class="n">__</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="n">ancestor</span><span class="p">,</span> <span class="p">[])</span>
            <span class="k">if</span> <span class="n">ancestor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parsers</span><span class="p">:</span>
                <span class="c1"># Dummy parser - since there&#39;s nothing to run, require the subparser.</span>
                <span class="n">required_subparser</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">argspec</span> <span class="o">=</span> <span class="n">log_args</span><span class="p">(</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span>
                    <span class="sa">f</span><span class="s2">&quot;Subparsers(</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">prev_ancestor</span><span class="p">)</span><span class="si">}</span><span class="s2">).&quot;</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_subparsers</span><span class="p">[</span><span class="n">prev_ancestor</span><span class="p">]</span><span class="o">.</span><span class="n">add_parser</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                    <span class="c1"># Args for the call are below:</span>
                    <span class="n">ancestor</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                    <span class="n">help</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
                    <span class="n">formatter_class</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_formatter</span><span class="p">,</span>
                    <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_extra_argparser_options</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_parsers</span><span class="p">[</span><span class="n">ancestor</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subparsers</span><span class="p">[</span><span class="n">prev_ancestor</span><span class="p">]</span><span class="o">.</span><span class="n">add_parser</span><span class="p">(</span><span class="o">*</span><span class="n">argspec</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">argspec</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ancestor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subparsers</span><span class="p">:</span>
                <span class="c1"># Add subparser to the parent command&#39;s parser.</span>
                <span class="n">ancestor_cmd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_commands</span><span class="p">[</span><span class="n">ancestor</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">input_method</span><span class="o">.</span><span class="n">is_positional</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">ancestor_cmd</span><span class="o">.</span><span class="n">args</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="n">ArguablyException</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Command `</span><span class="si">{</span><span class="n">ancestor</span><span class="si">}</span><span class="s2">` cannot have both subcommands and positional arguments.&quot;</span>
                    <span class="p">)</span>
                <span class="n">argspec</span> <span class="o">=</span> <span class="n">log_args</span><span class="p">(</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span>
                    <span class="sa">f</span><span class="s2">&quot;Parser(</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">ancestor</span><span class="p">)</span><span class="si">}</span><span class="s2">).&quot;</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_parsers</span><span class="p">[</span><span class="n">ancestor</span><span class="p">]</span><span class="o">.</span><span class="n">add_subparsers</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                    <span class="c1"># Args for the call are below:</span>
                    <span class="n">parser_class</span><span class="o">=</span><span class="n">ArgumentParser</span><span class="p">,</span>
                    <span class="n">dest</span><span class="o">=</span><span class="n">ancestor_cmd</span><span class="o">.</span><span class="n">get_subcommand_metavar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_options</span><span class="o">.</span><span class="n">command_metavar</span><span class="p">),</span>
                    <span class="n">metavar</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_options</span><span class="o">.</span><span class="n">command_metavar</span><span class="p">,</span>
                    <span class="n">required</span><span class="o">=</span><span class="n">required_subparser</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_subparsers</span><span class="p">[</span><span class="n">ancestor</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parsers</span><span class="p">[</span><span class="n">ancestor</span><span class="p">]</span><span class="o">.</span><span class="n">add_subparsers</span><span class="p">(</span><span class="o">*</span><span class="n">argspec</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">argspec</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">prev_ancestor</span> <span class="o">=</span> <span class="n">ancestor</span>
        <span class="k">return</span> <span class="n">prev_ancestor</span>

    <span class="nd">@contextmanager</span>
    <span class="k">def</span> <span class="nf">current_parser</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">:</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="kc">None</span><span class="p">]:</span>
        <span class="n">last_parser</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_parser</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_parser</span> <span class="o">=</span> <span class="n">parser</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">yield</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_current_parser</span> <span class="o">=</span> <span class="n">last_parser</span>

    <span class="k">def</span> <span class="nf">error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prints an error message and exits. Should only be used for when a value from the command line is not of the</span>
<span class="sd">        correct form.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_parser</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ArguablyException</span><span class="p">(</span><span class="s2">&quot;Unknown current parser.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_parser</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>  <span class="c1"># This will exit the script</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">call_ancestors</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">always_subcommand</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">auto_alias_cmds</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">auto_alias_params</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">version_flag</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">show_defaults</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">show_types</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">max_description_offset</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">60</span><span class="p">,</span>
        <span class="n">max_width</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">120</span><span class="p">,</span>
        <span class="n">command_metavar</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;command&quot;</span><span class="p">,</span>
        <span class="n">output</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TextIO</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set up the argument parser, parse argv, and run the appropriate command(s)&quot;&quot;&quot;</span>

        <span class="c1"># Set options</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_options</span> <span class="o">=</span> <span class="n">_ContextOptions</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">locals</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="s2">&quot;self&quot;</span><span class="p">})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_extra_argparser_options</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_options</span><span class="o">.</span><span class="n">output</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_is_calling_target</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">only_one_cmd</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_command_decorator_info</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_options</span><span class="o">.</span><span class="n">always_subcommand</span>

        <span class="c1"># Grab the description</span>
        <span class="kn">import</span> <span class="nn">__main__</span>

        <span class="n">description</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span> <span class="k">if</span> <span class="n">__main__</span><span class="o">.</span><span class="vm">__doc__</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">__main__</span><span class="o">.</span><span class="vm">__doc__</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n\n</span><span class="s2">&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># TODO: Rewrite this code to remove the need for this line</span>
        <span class="n">add_root_help</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span>
            <span class="nb">iter</span><span class="p">(</span><span class="n">info</span><span class="o">.</span><span class="n">help</span> <span class="k">for</span> <span class="n">info</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_command_decorator_info</span> <span class="k">if</span> <span class="n">info</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;__root__&quot;</span> <span class="ow">or</span> <span class="n">only_one_cmd</span><span class="p">),</span> <span class="kc">True</span>
        <span class="p">)</span>

        <span class="c1"># Set up the root parser</span>
        <span class="n">argspec</span> <span class="o">=</span> <span class="n">log_args</span><span class="p">(</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;Initializing </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="s1">&#39;__root__&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2"> parser: &quot;</span><span class="p">,</span>
            <span class="n">ArgumentParser</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="c1"># Args for the call are below:</span>
            <span class="n">prog</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_options</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">,</span>
            <span class="n">formatter_class</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_formatter</span><span class="p">,</span>
            <span class="n">add_help</span><span class="o">=</span><span class="n">add_root_help</span><span class="p">,</span>
            <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_extra_argparser_options</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">root_parser</span> <span class="o">=</span> <span class="n">ArgumentParser</span><span class="p">(</span><span class="o">*</span><span class="n">argspec</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">argspec</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parsers</span><span class="p">[</span><span class="s2">&quot;__root__&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">root_parser</span>

        <span class="c1"># Add version flags if necessary</span>
        <span class="n">argparse_version_flags</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_options</span><span class="o">.</span><span class="n">version_flag</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">__main__</span><span class="p">,</span> <span class="s2">&quot;__version__&quot;</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">ArguablyException</span><span class="p">(</span><span class="s2">&quot;__version__ must be defined if version_flag is set&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_options</span><span class="o">.</span><span class="n">version_flag</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="n">argparse_version_flags</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_options</span><span class="o">.</span><span class="n">version_flag</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">argparse_version_flags</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;--version&quot;</span><span class="p">,)</span>
            <span class="n">version_string</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;%(prog)s </span><span class="si">{</span><span class="n">__main__</span><span class="o">.</span><span class="n">__version__</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">argspec</span> <span class="o">=</span> <span class="n">log_args</span><span class="p">(</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span>
                <span class="sa">f</span><span class="s2">&quot;Parser(</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="s1">&#39;__root__&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">).&quot;</span><span class="p">,</span>
                <span class="n">root_parser</span><span class="o">.</span><span class="n">add_argument</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                <span class="c1"># Args for the call are below:</span>
                <span class="o">*</span><span class="n">argparse_version_flags</span><span class="p">,</span>
                <span class="n">action</span><span class="o">=</span><span class="s2">&quot;version&quot;</span><span class="p">,</span>
                <span class="n">version</span><span class="o">=</span><span class="n">version_string</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">root_parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="o">*</span><span class="n">argspec</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">argspec</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Check the number of commands we have</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_command_decorator_info</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ArguablyException</span><span class="p">(</span><span class="s2">&quot;At least one command is required&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">command_decorator_info</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_command_decorator_info</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="s2">&quot;__root__&quot;</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">))</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="n">only_one_cmd</span><span class="p">:</span>
                <span class="n">parent_name</span> <span class="o">=</span> <span class="s2">&quot;__root__&quot;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_parsers</span><span class="p">[</span><span class="n">command_decorator_info</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parsers</span><span class="p">[</span><span class="s2">&quot;__root__&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">parent_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_subparser_tree</span><span class="p">(</span><span class="n">command_decorator_info</span><span class="p">)</span>

            <span class="c1"># Assign an alias, if needed</span>
            <span class="k">if</span> <span class="n">command_decorator_info</span><span class="o">.</span><span class="n">alias</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_options</span><span class="o">.</span><span class="n">auto_alias_cmds</span><span class="p">:</span>
                <span class="n">command_decorator_info</span><span class="o">.</span><span class="n">alias</span> <span class="o">=</span> <span class="n">find_alias</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_command_aliases</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">command_decorator_info</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

            <span class="c1"># Process command and its args</span>
            <span class="n">cmd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_decorator_info</span><span class="p">(</span><span class="n">command_decorator_info</span><span class="p">)</span>

            <span class="c1"># Save command and its alias to the dicts</span>
            <span class="k">if</span> <span class="n">cmd</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_commands</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ArguablyException</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Name `</span><span class="si">{</span><span class="n">cmd</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">` is already taken&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cmd</span><span class="o">.</span><span class="n">alias</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">cmd</span><span class="o">.</span><span class="n">alias</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_command_aliases</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">ArguablyException</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Alias `</span><span class="si">{</span><span class="n">cmd</span><span class="o">.</span><span class="n">alias</span><span class="si">}</span><span class="s2">` for `</span><span class="si">{</span><span class="n">cmd</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">` is already taken by &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;`</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_command_aliases</span><span class="p">[</span><span class="n">cmd</span><span class="o">.</span><span class="n">alias</span><span class="p">]</span><span class="si">}</span><span class="s2">`&quot;</span>
                    <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_command_aliases</span><span class="p">[</span><span class="n">cmd</span><span class="o">.</span><span class="n">alias</span><span class="p">]</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">.</span><span class="n">name</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_commands</span><span class="p">[</span><span class="n">cmd</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">cmd</span>

            <span class="c1"># Add the parser for the command</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">only_one_cmd</span> <span class="ow">and</span> <span class="n">cmd</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="s2">&quot;__root__&quot;</span><span class="p">:</span>
                <span class="n">argspec</span> <span class="o">=</span> <span class="n">log_args</span><span class="p">(</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span>
                    <span class="sa">f</span><span class="s2">&quot;Subparsers(</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">parent_name</span><span class="p">)</span><span class="si">}</span><span class="s2">).&quot;</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_subparsers</span><span class="p">[</span><span class="n">parent_name</span><span class="p">]</span><span class="o">.</span><span class="n">add_parser</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                    <span class="c1"># Args for the call are below:</span>
                    <span class="n">cmd</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                    <span class="n">aliases</span><span class="o">=</span><span class="p">[</span><span class="n">cmd</span><span class="o">.</span><span class="n">alias</span><span class="p">]</span> <span class="k">if</span> <span class="n">cmd</span><span class="o">.</span><span class="n">alias</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[],</span>
                    <span class="n">help</span><span class="o">=</span><span class="n">cmd</span><span class="o">.</span><span class="n">description</span><span class="p">,</span>
                    <span class="n">description</span><span class="o">=</span><span class="n">cmd</span><span class="o">.</span><span class="n">description</span><span class="p">,</span>
                    <span class="n">formatter_class</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_formatter</span><span class="p">,</span>
                    <span class="n">add_help</span><span class="o">=</span><span class="n">cmd</span><span class="o">.</span><span class="n">add_help</span><span class="p">,</span>
                    <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_extra_argparser_options</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_parsers</span><span class="p">[</span><span class="n">cmd</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subparsers</span><span class="p">[</span><span class="n">parent_name</span><span class="p">]</span><span class="o">.</span><span class="n">add_parser</span><span class="p">(</span><span class="o">*</span><span class="n">argspec</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">argspec</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="c1"># Add the arguments to the command&#39;s parser</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_set_up_args</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="c1"># Special handling for version flags for __root__</span>
                <span class="k">if</span> <span class="n">cmd</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="s2">&quot;__root__&quot;</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">e</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">e</span><span class="o">.</span><span class="n">message</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;conflicting option string&quot;</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="n">e</span>
                <span class="c1"># e.message == `conflicting option strings: -v, --version`</span>
                <span class="n">conflicts</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">message</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">)</span>
                <span class="n">filtered_conflicts</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">conflicts</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">argparse_version_flags</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">filtered_conflicts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">e</span>
                <span class="k">raise</span> <span class="n">ArguablyException</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Conflict due to `version_flag` being set and __root__ having a parameter with a conflicting name.&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot; Conflicting args: </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">conflicts</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="c1"># Use the function description, not the __main__ docstring, if only one command</span>
        <span class="k">if</span> <span class="n">only_one_cmd</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parsers</span><span class="p">[</span><span class="s2">&quot;__root__&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">description</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_commands</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span><span class="o">.</span><span class="n">description</span>

        <span class="c1"># Make the magic happen</span>
        <span class="n">parsed_args</span> <span class="o">=</span> <span class="nb">vars</span><span class="p">(</span><span class="n">root_parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">())</span>

        <span class="c1"># Resolve the command that needs to be called</span>
        <span class="k">if</span> <span class="n">only_one_cmd</span><span class="p">:</span>
            <span class="n">cmd</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_commands</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_current_parser</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parsers</span><span class="p">[</span><span class="s2">&quot;__root__&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Find the actual command we need to execute by traversing the subparser tree. Call each stop along the way</span>
            <span class="c1"># if the call_ancestors option is set to True.</span>
            <span class="n">path</span> <span class="o">=</span> <span class="s2">&quot;__root__&quot;</span>
            <span class="k">while</span> <span class="n">path</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subparsers</span><span class="p">:</span>
                <span class="c1"># Find the variable name for this subparser&#39;s command metavar and read the value. If it&#39;s none, run the</span>
                <span class="c1"># current stop of our path in the tree.</span>
                <span class="n">subcmd_metavar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_commands</span><span class="p">[</span><span class="n">path</span><span class="p">]</span><span class="o">.</span><span class="n">get_subcommand_metavar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_options</span><span class="o">.</span><span class="n">command_metavar</span><span class="p">)</span>
                <span class="n">subcmd_name</span> <span class="o">=</span> <span class="n">parsed_args</span><span class="p">[</span><span class="n">subcmd_metavar</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">subcmd_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">break</span>

                <span class="c1"># Resolve any command aliases</span>
                <span class="k">if</span> <span class="n">subcmd_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_command_aliases</span><span class="p">:</span>
                    <span class="n">subcmd_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_command_aliases</span><span class="p">[</span><span class="n">subcmd_name</span><span class="p">]</span>

                <span class="c1"># Call the ancestor if call_ancestors is set</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_options</span><span class="o">.</span><span class="n">call_ancestors</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_is_calling_target</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_current_parser</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parsers</span><span class="p">[</span><span class="n">path</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_commands</span><span class="p">[</span><span class="n">path</span><span class="p">]</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">parsed_args</span><span class="p">)</span>

                <span class="c1"># Update the path and continue</span>
                <span class="k">if</span> <span class="n">path</span> <span class="o">==</span> <span class="s2">&quot;__root__&quot;</span><span class="p">:</span>
                    <span class="n">path</span> <span class="o">=</span> <span class="n">subcmd_name</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">path</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="n">subcmd_name</span><span class="si">}</span><span class="s2">&quot;</span>

            <span class="c1"># If the command is unknown, print the help for the most recent parent</span>
            <span class="k">if</span> <span class="n">path</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_commands</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_parsers</span><span class="p">[</span><span class="n">path</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">print_help</span><span class="p">(</span><span class="n">file</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_options</span><span class="o">.</span><span class="n">output</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">path</span> <span class="o">==</span> <span class="s2">&quot;__root__&quot;</span><span class="p">:</span>
                <span class="n">root_parser</span><span class="o">.</span><span class="n">print_help</span><span class="p">(</span><span class="n">file</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_options</span><span class="o">.</span><span class="n">output</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">None</span>

            <span class="c1"># Found command</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_current_parser</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parsers</span><span class="p">[</span><span class="n">path</span><span class="p">]</span>
            <span class="n">cmd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_commands</span><span class="p">[</span><span class="n">path</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_is_calling_target</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">parsed_args</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_parser</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_build_subtype</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">parent_func_arg_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">subtype_info</span><span class="p">:</span> <span class="n">SubtypeDecoratorInfo</span><span class="p">,</span> <span class="n">build_kwargs</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="n">type_</span> <span class="o">=</span> <span class="n">subtype_info</span><span class="o">.</span><span class="n">type_</span>
        <span class="n">factory</span> <span class="o">=</span> <span class="n">subtype_info</span><span class="o">.</span><span class="n">factory</span> <span class="ow">or</span> <span class="n">type_</span><span class="o">.</span><span class="fm">__call__</span>
        <span class="n">template</span> <span class="o">=</span> <span class="n">subtype_info</span><span class="o">.</span><span class="n">factory</span> <span class="ow">or</span> <span class="n">type_</span><span class="o">.</span><span class="fm">__init__</span>  <span class="c1"># type: ignore[misc]</span>
        <span class="n">hints</span> <span class="o">=</span> <span class="n">get_type_hints</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="n">include_extras</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">normalized_kwargs</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">inspect</span><span class="o">.</span><span class="n">Parameter</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">k</span><span class="p">:</span> <span class="n">v</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">template</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">kind</span> <span class="o">!=</span> <span class="n">v</span><span class="o">.</span><span class="n">VAR_POSITIONAL</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">kind</span> <span class="o">!=</span> <span class="n">v</span><span class="o">.</span><span class="n">VAR_KEYWORD</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="n">missing_required_keys</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">normalize_name</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">build_kwargs</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="s2">&quot;self&quot;</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">missing_required_keys</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">missing_specs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">missing_required_keys</span><span class="p">:</span>
                <span class="n">arg_value_type</span><span class="p">,</span> <span class="n">modifiers</span> <span class="o">=</span> <span class="n">CommandArg</span><span class="o">.</span><span class="n">normalize_type</span><span class="p">(</span><span class="n">type_</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">hints</span><span class="p">)</span>
                <span class="n">missing_specs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">arg_value_type</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;the following keys are required for </span><span class="si">{</span><span class="n">parent_func_arg_name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">missing_specs</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Iterate over all parameters</span>
        <span class="k">for</span> <span class="n">func_arg_name</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">func_arg_name</span> <span class="o">=</span> <span class="n">normalize_name</span><span class="p">(</span><span class="n">func_arg_name</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">func_arg_name</span> <span class="o">==</span> <span class="s2">&quot;self&quot;</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">param_value</span> <span class="o">=</span> <span class="n">build_kwargs</span><span class="p">[</span><span class="n">func_arg_name</span><span class="p">]</span>
                <span class="k">del</span> <span class="n">build_kwargs</span><span class="p">[</span><span class="n">func_arg_name</span><span class="p">]</span>
                <span class="n">arg_value_type</span><span class="p">,</span> <span class="n">modifiers</span> <span class="o">=</span> <span class="n">CommandArg</span><span class="o">.</span><span class="n">normalize_type</span><span class="p">(</span><span class="n">type_</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">hints</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">ArguablyException</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ArguablyException</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error processing parameter </span><span class="si">{</span><span class="n">func_arg_name</span><span class="si">}</span><span class="s2"> of subtype </span><span class="si">{</span><span class="n">type_</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">modifiers</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ArguablyException</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Error processing parameter </span><span class="si">{</span><span class="n">func_arg_name</span><span class="si">}</span><span class="s2"> of subtype </span><span class="si">{</span><span class="n">type_</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">: Cannot use modifiers &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;on subtypes&quot;</span>
                <span class="p">)</span>
            <span class="n">normalized_kwargs</span><span class="p">[</span><span class="n">func_arg_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">arg_value_type</span><span class="p">(</span><span class="n">param_value</span><span class="p">)</span>

        <span class="c1"># The calls to .error() cause an exit</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">build_kwargs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unexpected keys for </span><span class="si">{</span><span class="n">parent_func_arg_name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">build_kwargs</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">build_kwargs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unexpected key for </span><span class="si">{</span><span class="n">parent_func_arg_name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">build_kwargs</span><span class="p">))</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">factory</span><span class="p">(</span><span class="o">**</span><span class="n">normalized_kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">resolve_subtype</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">func_arg_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">arg_value_type</span><span class="p">:</span> <span class="nb">type</span><span class="p">,</span> <span class="n">subtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">build_kwargs</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="n">options</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_subtype</span><span class="p">(</span><span class="n">arg_value_type</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">options</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">options</span> <span class="o">=</span> <span class="p">[</span><span class="n">SubtypeDecoratorInfo</span><span class="p">(</span><span class="n">arg_value_type</span><span class="p">)]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">options</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_subtype</span><span class="p">(</span><span class="n">func_arg_name</span><span class="p">,</span> <span class="n">options</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">build_kwargs</span><span class="p">)</span>
        <span class="n">matches</span> <span class="o">=</span> <span class="p">[</span><span class="n">op</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">options</span> <span class="k">if</span> <span class="n">op</span><span class="o">.</span><span class="n">alias</span> <span class="o">==</span> <span class="n">subtype</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unknown subtype `</span><span class="si">{</span><span class="n">subtype</span><span class="si">}</span><span class="s2">` for </span><span class="si">{</span><span class="n">func_arg_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ArguablyException</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;More than one match for subtype `</span><span class="si">{</span><span class="n">subtype</span><span class="si">}</span><span class="s2">` of type </span><span class="si">{</span><span class="n">arg_value_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_subtype</span><span class="p">(</span><span class="n">func_arg_name</span><span class="p">,</span> <span class="n">matches</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">build_kwargs</span><span class="p">)</span>


<span class="n">context</span> <span class="o">=</span> <span class="n">_Context</span><span class="p">()</span>


<span class="c1">########################################################################################################################</span>
<span class="c1"># Exposed for API</span>


<span class="n">run</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">run</span>
<span class="n">is_target</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">is_calling_target</span>
<span class="n">error</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">error</span>


<div class="viewcode-block" id="command"><a class="viewcode-back" href="../../index.html#arguably.command">[docs]</a><span class="k">def</span> <span class="nf">command</span><span class="p">(</span>
    <span class="n">func</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="c1"># Arguments below are passed through to `_CommandDecoratorInfo`</span>
    <span class="n">alias</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">help</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mark a decorated function as a command. If multiple functions are decorated with this, they will be available as</span>
<span class="sd">    subcommands.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">wrap</span><span class="p">(</span><span class="n">func_</span><span class="p">:</span> <span class="n">Callable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">:</span>
        <span class="n">context</span><span class="o">.</span><span class="n">add_command</span><span class="p">(</span><span class="n">function</span><span class="o">=</span><span class="n">func_</span><span class="p">,</span> <span class="n">alias</span><span class="o">=</span><span class="n">alias</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="n">help</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">func_</span>

    <span class="c1"># Handle being called as either @arguably.command or @arguably.command()</span>
    <span class="c1"># We have type: ignore due to https://github.com/python/mypy/issues/10740</span>
    <span class="k">return</span> <span class="n">wrap</span> <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">wrap</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>  <span class="c1"># type: ignore[return-value]</span></div>


<div class="viewcode-block" id="subtype"><a class="viewcode-back" href="../../index.html#arguably.subtype">[docs]</a><span class="k">def</span> <span class="nf">subtype</span><span class="p">(</span>
    <span class="bp">cls</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">type</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="c1"># Arguments from `_CommandDecoratorInfo`. Here for IDE help.</span>
    <span class="n">alias</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="nb">type</span><span class="p">],</span> <span class="nb">type</span><span class="p">],</span> <span class="nb">type</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mark a decorated class as a subtype that should be buildable for a parameter using arg.builder(). The alias</span>
<span class="sd">    parameter is required.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">wrap</span><span class="p">(</span><span class="n">cls_</span><span class="p">:</span> <span class="nb">type</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">type</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cls_</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">ArguablyException</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Decorated value </span><span class="si">{</span><span class="n">cls_</span><span class="si">}</span><span class="s2"> is not a type, which is required for `@arguably.subtype()`&quot;</span>
            <span class="p">)</span>
        <span class="n">context</span><span class="o">.</span><span class="n">add_subtype</span><span class="p">(</span><span class="n">type_</span><span class="o">=</span><span class="n">cls_</span><span class="p">,</span> <span class="n">alias</span><span class="o">=</span><span class="n">alias</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cls_</span>

    <span class="c1"># Handle being called as either @arguably.subtype or @arguably.subtype()</span>
    <span class="k">return</span> <span class="n">wrap</span> <span class="k">if</span> <span class="bp">cls</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">wrap</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span></div>
</pre></div>
        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2023, treykeown
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </div>
</div><script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/scripts/furo.js"></script>
    </body>
</html>