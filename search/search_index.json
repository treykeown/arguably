{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>          The best Python CLI library, arguably.      </p> <p> </p> <p><code>arguably</code> turns functions and docstrings into command line interfaces (CLIs). <code>arguably</code> has a tiny API and is extremely easy to integrate. You can also use it directly through <code>python3 -m arguably your_script.py</code>, more on that here.</p> <p>To use <code>arguably</code> in a script, decorate any functions that should appear on the command line with <code>@arguably.command</code>, then call <code>arguably.run()</code>. If multiple functions are decorated, they'll all appear as subcommands. You can even have multiple levels of subcommands: <code>def s3__ls()</code> becomes <code>s3 ls</code>.</p> [source] <pre><code>#!/usr/bin/env python3\nimport arguably\n\n@arguably.command\ndef some_function(required, not_required=2, *others: int, option: float = 3.14):\n\"\"\"\n    this function is on the command line!\n\n    Args:\n        required: a required argument\n        not_required: this one isn't required, since it has a default value\n        *others: all the other positional arguments go here\n        option: [-x] keyword-only args are options, short name is in brackets\n    \"\"\"\n    print(f\"{required=}, {not_required=}, {others=}, {option=}\")\n\nif __name__ == \"__main__\":\n    arguably.run()\n</code></pre> <p>becomes</p> <pre><code>user@machine:~$ ./intro.py -h\nusage: intro.py [-h] [-x OPTION] required [not-required] [others ...]\n\nthis function is on the command line!\n\npositional arguments:\n  required             a required argument (type: str)\n  not-required         this one isn't required, since it has a default value (type: int, default: 2)\n  others               all the other positional arguments go here (type: int)\n\noptions:\n  -h, --help           show this help message and exit\n  -x, --option OPTION  keyword-only args are options, short name is in brackets (type: float, default: 3.14)\n</code></pre> <p>Arguments to the CLI look just like calling the Python function.</p> <pre><code>&gt;&gt;&gt; from intro import some_function\n&gt;&gt;&gt; some_function(\"asdf\", 0, 7, 8, 9, option=2.71)\nrequired='asdf', not_required=0, others=(7, 8, 9), option=2.71\n</code></pre> <pre><code>user@machine:~$ ./intro.py asdf 0 7 8 9 --option 2.71\nrequired='asdf', not_required=0, others=(7, 8, 9), option=2.71\n</code></pre> <p><code>arguably</code> uses your docstrings to automatically generate help messages. It supports all major formats for docstrings: reStructuredText, Google, Numpydoc, and Epydoc.</p> <p>Type annotations are optional, but <code>arguably</code> can use them to automatically convert arguments. It has smart handling for mapping built-in types to the command line, including <code>tuple</code>, <code>list</code>, <code>enum.Enum</code>, and <code>enum.Flag</code>.</p> <p>There are also a few special behaviors you can attach to a parameter via <code>Annotated[]</code> and the <code>arguably.arg.*</code> functions. Using <code>arguably.arg.builder()</code>, you can even build an object to pass in from the command line (using syntax inspired by QEMU):</p> [source] <pre><code>user@machine:~$ ./build.py --nic tap,model=e1000 --nic user,hostfwd=tcp::10022-:22\nnic=[TapNic(model='e1000'), UserNic(hostfwd='tcp::10022-:22')]\n</code></pre>"},{"location":"#no-integration-required","title":"No integration required","text":"<p>Don't want to write any code? Simply pass any Python script to <code>arguably</code> to give it a command line interface.</p> [source] <pre><code>user@machine:~$ python3 -m arguably party-trick.py -h\nusage: party-trick [-h] [--version] command ...\n\nthis is the docstring for the whole script\n\npositional arguments:\n  command\n    hello                   this is hello's docstring\n    goodbye                 any function from a script can be called\n    some-class              so can any __init__ for objects defined in the script\n    some-class.func-static  a @staticmethod on a class can be called\n    some-class.func-cls     so can a @classmethod\n\noptions:\n  -h, --help                show this help message and exit\n  --version                 show program's version number and exit\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<p>Install using <code>pip install arguably</code>. If you want to install using <code>conda</code>, please comment on this issue.</p>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Why arguably?: https://treykeown.github.io/arguably/why/</li> <li>Examples: https://treykeown.github.io/arguably/examples/</li> <li>Tutorial: https://treykeown.github.io/arguably/tutorial/intro/</li> <li>API Reference: https://treykeown.github.io/arguably/api-reference/</li> </ul>"},{"location":"#dependencies","title":"Dependencies","text":"<p>All of <code>arguably</code> is built on top of <code>argparse</code>. It has two dependencies:</p> <ul> <li><code>docstring-parser</code> for parsing function docstrings</li> <li><code>typing-extensions</code> for <code>Annotated[]</code> support in Python 3.8 (only needed for that version)</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>Ideas and help are very much appreciated! There's a guide for getting started with contributing to <code>arguably</code> that shows you how to run tests and pre-commit hooks.</p> <ul> <li>Contributing: https://treykeown.github.io/arguably/contributing/</li> </ul>"},{"location":"#future-roadmap","title":"Future roadmap","text":"<p>If you have any interest in these (either as a user or implementer), please leave a comment!</p> <ul> <li>#8 - Display all enum options in a command group</li> <li>#9 - Both positive and negative boolean flags</li> <li>#10 - Take inputs from environment variables</li> <li>#13 - Implement config interface</li> <li>#16 - Integration with rich for formatted CLI output</li> </ul>"},{"location":"api-reference/","title":"API Reference","text":""},{"location":"api-reference/#overview","title":"Overview","text":""},{"location":"api-reference/#need-to-know","title":"Need-to-know","text":"<p>In short, only two functions are required to use <code>arguably</code>:</p> <ul> <li><code>@arguably.command</code> to mark which functions to put on the CLI</li> <li><code>arguably.run()</code> parses the CLI arguments and calls the marked functions</li> </ul>"},{"location":"api-reference/#extras","title":"Extras","text":"<p>The rest of the functions aren't necessary except in specific use cases:</p> <ul> <li><code>arguably.error()</code> lets you error out if an input is the correct type but isn't acceptable</li> <li><code>arguably.is_target()</code> tells you if the targeted command is being run, or if one of its ancestors is being run</li> <li><code>@arguably.subtype</code> marks a subclass as buildable through <code>arguably.arg.builder()</code></li> </ul>"},{"location":"api-reference/#special-behaviors","title":"Special behaviors","text":"<p>There are a number of special behaviors you can attach to a parameter. These utilize the ability to attach metadata to a type using <code>typing.Annotated[]</code>:</p> <pre><code>def foo(\n    param: Annotated[&lt;param_type&gt;, arguably.arg.*()]\n):\n</code></pre> <ul> <li><code>arguably.arg.required()</code> requires <code>list[]</code> and <code>*args</code> params to not be empty, or marks an <code>--option</code> as required.</li> <li><code>arguably.arg.count()</code> counts the number of times an option appears: <code>-vvvv</code> gives <code>4</code>.</li> <li><code>arguably.arg.choices(*choices)</code> restricts inputs to <code>choices</code></li> <li><code>arguably.arg.missing(omit_value)</code> <code>--option foo</code> yields <code>foo</code>, but this allows the value to be omitted: just <code>--option</code> will use the given <code>omit_value</code>.</li> <li><code>arguably.arg.handler(func)</code> skips all the argument processing <code>arguably</code> does and just calls <code>func</code></li> <li><code>arguably.arg.builder()</code> treats the input as instructions on how to build a class</li> </ul>"},{"location":"api-reference/#exceptions","title":"Exceptions","text":"<p>Additionally, there are two exceptions:</p> <ul> <li><code>arguably.ArguablyException</code> raised if you messed up when setting up <code>arguably</code></li> <li><code>arguably.ArguablyWarning</code> passed to <code>warnings.warn()</code> if you messed up when setting up <code>arguably</code>, but not badly. Also used if <code>python3 -m arguably &lt;script.py&gt;</code> is used, but there were some problems running the script.</li> </ul>"},{"location":"api-reference/#arguably","title":"arguably","text":""},{"location":"api-reference/#arguably.command","title":"arguably.command","text":"<pre><code>arguably.command(func=None, /, *, alias=None, help=True)\n</code></pre> <p>Mark a function as a command that should appear on the CLI. If multiple functions are decorated with this, they will all be available as subcommands. If only one function is decorated, it is automatically selected - no need to specify it on the CLI.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Optional[Callable]</code> <p>The target function.</p> <code>None</code> <code>alias</code> <code>Optional[str]</code> <p>An alias for this function. For example, <code>@arguably.command(alias=\"h\")</code> would alias <code>h</code> to the function that follows.</p> <code>None</code> <code>help</code> <code>bool</code> <p>If <code>False</code>, the help flag <code>-h/--help</code> will not automatically be added to this function.</p> <code>True</code> <p>Returns:</p> Type Description <code>Callable</code> <p>If called with parens <code>@arguably.command(...)</code>, returns the decorated function. If called without parens <code>@arguably.command</code>, returns the function <code>wrap(func_)</code>, which returns <code>func_</code>.</p> <p>Examples:</p> <pre><code>#!/usr/bin/env python3\nimport arguably\n\n@arguably.command\ndef some_function(required, not_required=2, *others: int, option: float = 3.14):\n\"\"\"\n    this function is on the command line!\n\n    Args:\n        required: a required argument\n        not_required: this one isn't required, since it has a default value\n        *others: all the other positional arguments go here\n        option: [-x] keyword-only args are options, short name is in brackets\n    \"\"\"\n\nif __name__ == \"__main__\":\n    arguably.run()\n</code></pre> <pre><code>user@machine:~$ python3 intro.py -h\nusage: intro.py [-h] [-x OPTION] required [not-required] [others ...]\n\nthis function is on the command line!\n\npositional arguments:\n  required             a required argument (type: str)\n  not-required         this one isn't required, since it has a default value (type: int, default: 2)\n  others               all the other positional arguments go here (type: int)\n\noptions:\n  -h, --help           show this help message and exit\n  -x, --option OPTION  keyword-only args are options, short name is in brackets (type: float, default: 3.14)\n</code></pre> <p>Or, with multiple commands:</p> <pre><code>#!/usr/bin/env python3\nimport arguably\n\n@arguably.command(alias=\"f\")\ndef first(): ...\n\n@arguably.command(alias=\"s\")\ndef second(): ...\n\n@arguably.command\ndef second__subcmd1(): ...\n\ndef second__subcmd2(): ...\narguably.command(second__subcmd2)  # Can also be invoked this way\n\nif __name__ == \"__main__\":\n    arguably.run()\n</code></pre> <pre><code>user@machine:~$ python3 command.py -h\nusage: command-example-2.py [-h] command ...\n\npositional arguments:\n  command\n    first (f)\n    second (s)\n\noptions:\n  -h, --help    show this help message and exit\n</code></pre> <pre><code>user@machine:~$ python3 command.py s -h\nusage: command-example-2.py second [-h] command ...\n\npositional arguments:\n  command\n    subcmd1\n    subcmd2\n\noptions:\n  -h, --help  show this help message and exit\n</code></pre>"},{"location":"api-reference/#arguably.run","title":"arguably.run","text":"<pre><code>arguably.run(\n    name=None,\n    always_subcommand=False,\n    version_flag=False,\n    strict=True,\n    show_defaults=True,\n    show_types=True,\n    max_description_offset=60,\n    max_width=120,\n    command_metavar=\"command\",\n    output=None,\n)\n</code></pre> <p>Set up the argument parser, parse argv, and run the appropriate command(s)</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>Name of the script/program. Defaults to the filename or module name, depending on how the script is run. <code>$ python3 my/script.py</code> yields <code>script.py</code>, and <code>python3 -m my.script</code> yeilds <code>script</code>.</p> <code>None</code> <code>always_subcommand</code> <code>bool</code> <p>If true, will force a subcommand interface to be used, even if there's only one command.</p> <code>False</code> <code>version_flag</code> <code>Union[bool, Tuple[str], Tuple[str, str]]</code> <p>If true, adds an option to show the script version using the value of <code>__version__</code> in the invoked script. If a tuple of one or two strings is passed in, like <code>(\"-V\", \"--ver\")</code>, those are used instead of the default <code>--version</code>.</p> <code>False</code> <code>strict</code> <code>bool</code> <p>Will prevent the script from running if there are any <code>ArguablyException</code>s raised during CLI initialization.</p> <code>True</code> <code>show_defaults</code> <code>bool</code> <p>Show the default value (if any) for each argument at the end of its help string.</p> <code>True</code> <code>show_types</code> <code>bool</code> <p>Show the type of each argument at the end of its help string.</p> <code>True</code> <code>max_description_offset</code> <code>int</code> <p>The maximum number of columns before argument descriptions are printed. Equivalent to <code>max_help_position</code> in argparse.</p> <code>60</code> <code>max_width</code> <code>int</code> <p>The total maximum width of text to be displayed in the terminal. Equivalent to <code>width</code> in argparse.</p> <code>120</code> <code>command_metavar</code> <code>str</code> <p>The name shown in the usage string for taking in a subcommand. Change this if you have a conflicting argument name.</p> <code>'command'</code> <code>output</code> <code>Optional[TextIO]</code> <p>Where argparse output should be written - can write to a file, stderr, or anything similar.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>The return value from the called function.</p> <p>Examples:</p> <pre><code>#!/usr/bin/env python3\n\"\"\"description for this script\"\"\"\nfrom io import StringIO\n\nimport arguably\n\n__version__ = \"1.2.3\"\n\n@arguably.command\ndef example(): ...\n\nif __name__ == \"__main__\":\n    output = StringIO()\n    try:\n        arguably.run(\n            name=\"myname\",\n            always_subcommand=True,\n            version_flag=True,\n            command_metavar=\"mycmd\",\n            output=output\n        )\n    finally:\n        print(f\"Captured output length: {len(output.getvalue())=}\")\n        print()\n        print(output.getvalue(), end=\"\")\n</code></pre> <pre><code>user@machine:~$ python3 run.py -h\nCaptured output length: len(output.getvalue())=222\n\nusage: myname [-h] [--version] mycmd ...\n\ndescription for this script\n\npositional arguments:\n  mycmd\n    example\n\noptions:\n  -h, --help  show this help message and exit\n  --version   show program's version number and exit\n</code></pre> <pre><code>user@machine:~$ python3 run.py --version\nCaptured output length: len(output.getvalue())=13\n\nmyname 1.2.3\n</code></pre>"},{"location":"api-reference/#arguably.error","title":"arguably.error","text":"<pre><code>arguably.error(message)\n</code></pre> <p>Prints an error message and exits. Should be used when a CLI input is not of the correct form. <code>arguably</code> handles converting values to the correct type, but if extra validation is performed and fails, you should call this.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>A message to be printed to the console indicating why the input is wrong.</p> required <p>Raises:</p> Type Description <code>SystemExit</code> <p>The script will exit.</p> <p>Examples:</p> <pre><code>#!/usr/bin/env python3\nimport arguably\n\n@arguably.command\ndef high_five(*people):\n    if len(people) &gt; 5:\n        arguably.error(\"Too many people to high-five!\")\n    for person in people:\n        print(f\"High five, {person}!\")\n\nif __name__ == \"__main__\":\n    arguably.run()\n</code></pre> <pre><code>user@machine:~$ python3 error.py Graham John Terry Eric Terry Michael\nusage: error.py [-h] [people ...]\nerror.py: error: Too many people to high-five!\n</code></pre>"},{"location":"api-reference/#arguably.is_target","title":"arguably.is_target","text":"<pre><code>arguably.is_target()\n</code></pre> <p>Only useful if <code>invoke_ancestors=True</code>. Returns <code>True</code> if the targeted command is being executed and <code>False</code> if not. This is safe to call even if <code>arguably</code> is not being used, since it returns <code>True</code> if <code>arguably.run()</code> is not being used.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>False</code> if <code>arguably.run()</code> was called and the currently running command is not the targeted command, <code>True</code> in every other case.</p> <p>Examples:</p> <pre><code>import arguably\n\n@arguably.command\ndef __root__(*, config_file=None):\n    print(f\"Using config {config_file}\")\n    if not arguably.is_target():\n        return\n    print(\"__root__ is the target!\")\n\n@arguably.command\ndef hi():\n    print(\"hi is the target!\")\n\n@arguably.command\ndef bye():\n    print(\"bye is the target!\")\n\nif __name__ == \"__main__\":\n    arguably.run()\n</code></pre> <pre><code>user@machine:~$ python3 is_target.py --config-file foo.yml\nUsing config foo.yml\n__root__ is the target!\n</code></pre> <pre><code>user@machine:~$ python3 is_target.py --config-file foo.yml hi\nUsing config foo.yml\nhi is the target!\n</code></pre>"},{"location":"api-reference/#arguably.subtype","title":"arguably.subtype","text":"<pre><code>arguably.subtype(cls=None, /, *, alias)\n</code></pre> <p>Mark a decorated class as a subtype that should be buildable for a parameter using arg.builder(). The alias parameter is required.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>Optional[type]</code> <p>The target class.</p> <code>None</code> <code>alias</code> <code>str</code> <p>An alias for this class. For example, <code>@arguably.subtype(alias=\"foo\")</code> would cause this class to be built any time an applicable arg is given a string starting with <code>foo,...</code></p> required <p>Returns:</p> Type Description <code>Union[Callable[[type], type], type]</code> <p>If called with parens <code>@arguably.subtype(...)</code>, returns the decorated class. If called without parens <code>@arguably.subtype</code>, returns the function <code>wrap(cls_)</code>, which returns <code>cls_</code>.</p> <p>Examples:</p> <pre><code>import arguably\nfrom dataclasses import dataclass\nfrom typing import Annotated\n\nclass Nic: ...\n\n@arguably.subtype(alias=\"tap\")\n@dataclass\nclass TapNic(Nic):\n    model: str\n\n@dataclass\nclass UserNic(Nic):\n    hostfwd: str\n\narguably.subtype(UserNic, alias=\"user\")  # Can also be called like this\n\n@arguably.command\ndef qemu_style(*, nic: Annotated[list[Nic], arguably.arg.builder()]):\n    print(f\"{nic=}\")\n\nif __name__ == \"__main__\":\n    arguably.run()\n</code></pre> <pre><code>user@machine:~$ python3 subtype.py --nic tap,model=e1000 --nic user,hostfwd=tcp::10022-:22\nnic=[TapNic(model='e1000'), UserNic(hostfwd='tcp::10022-:22')]\n</code></pre>"},{"location":"api-reference/#arguably.ArguablyException","title":"arguably.ArguablyException","text":"<pre><code>arguably.ArguablyException()\n</code></pre> <p>         Bases: <code>Exception</code></p> <p>Raised when a decorated function is incorrectly set up in some way. Will not be raised when a user provides incorrect input to the CLI.</p> <p>Examples:</p> <pre><code>#!/usr/bin/env python3\nimport arguably\n\n@arguably.command\ndef example(collision_, _collision):\n    print(\"You should never see this\")\n\nif __name__ == \"__main__\":\n    arguably.run()\n</code></pre> <pre><code>user@machine:~$ python3 arguably-exception.py\nTraceback (most recent call last):\n  File \".../arguably/etc/scripts/api-examples/arguably-exception.py\", line 9, in &lt;module&gt;\n    arguably.run()\n  File \".../arguably/arguably/_context.py\", line 706, in run\n    cmd = self._process_decorator_info(command_decorator_info)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \".../arguably/arguably/_context.py\", line 284, in _process_decorator_info\n    return Command(\n           ^^^^^^^^\n  File \"&lt;string&gt;\", line 9, in __init__\n  File \".../arguably/arguably/_commands.py\", line 214, in __post_init__\n    raise util.ArguablyException(\narguably._util.ArguablyException: Function argument `_collision` in `example` conflicts with `collision_`, both\nnames simplify to `collision`\n</code></pre>"},{"location":"api-reference/#arguably.ArguablyWarning","title":"arguably.ArguablyWarning","text":"<pre><code>arguably.ArguablyWarning()\n</code></pre> <p>         Bases: <code>UserWarning</code></p> <p>If strict checks are disabled through <code>arguably.run(strict=False)</code> this is emitted when a decorated function is incorrectly set up in some way, but arguably can continue. Will not be raised when a user provides incorrect input to the CLI.</p> <p>When <code>arguably</code> is directly invoked through <code>python3 -m arguably ...</code>, <code>strict=False</code> is always set.</p> <p>Note that this is a warning - it is used with <code>warnings.warn</code>.</p> <p>Examples:</p> <pre><code>def example_failed(collision_, _collision):\n    print(\"You should never see this\")\n\ndef example_ok():\n    print(\"All good\")\n</code></pre> <pre><code>user@machine:~$ python3 -m arguably arguably-warn.py -h\n.../arguably/etc/scripts/api-examples/arguably-warn.py:1: ArguablyWarning: Unable to add function\nexample_failed: Function argument `_collision` in `example-failed` conflicts with `collision_`, both names\nsimplify to `collision`\n  def example_failed(collision_, _collision):\nusage: arguably-warn [-h] command ...\n\npositional arguments:\n  command\n    example-ok\n\noptions:\n  -h, --help    show this help message and exit\n</code></pre>"},{"location":"api-reference/#arguablyarg","title":"arguably.arg","text":"<p>A collection of methods for adding a modifier to a parameter. Should be used in <code>Annotated[]</code>.</p> <p>Examples:</p> <pre><code>def foo(\n    *,\n    verbose: Annotated[int, arguably.arg.count()],\n):\n</code></pre>"},{"location":"api-reference/#arguably.arg.required","title":"arguably.arg.required","text":"<pre><code>arguably.arg.required()\n</code></pre> <p>Marks a field as required. For <code>*args</code> or a <code>list[]</code>, requires at least one item.</p> <p>Returns:</p> Type Description <code>mods.RequiredModifier</code> <p>A value for use with <code>Annotated[]</code>, stating that this parameter is required.</p> <p>Examples:</p> <pre><code>import arguably\nfrom typing import Annotated\n\n@arguably.command\ndef email(\n    from_: str,\n    *to: Annotated[str, arguably.arg.required()]\n):\n    print(f\"{from_=}\", f\"{to=}\")\n\nif __name__ == \"__main__\":\n    arguably.run()\n</code></pre> <p><pre><code>user@machine:~$ python3 arg-required.py -h\nusage: arg-required.py [-h] from to [to ...]\n\npositional arguments:\n  from        (type: str)\n  to          (type: str)\n\noptions:\n  -h, --help  show this help message and exit\n</code></pre> <pre><code>user@machine:~$ python3 arg-required.py sender@example.com\nusage: arg-required.py [-h] from to [to ...]\narg-required.py: error: the following arguments are required: to\n</code></pre></p>"},{"location":"api-reference/#arguably.arg.count","title":"arguably.arg.count","text":"<pre><code>arguably.arg.count()\n</code></pre> <p>Counts the number of times a flag is given. For example, <code>-vvvv</code> would yield <code>4</code>.</p> <p>Returns:</p> Type Description <code>mods.CountedModifier</code> <p>A value for use with <code>Annotated[]</code>, stating that this parameter should be counted.</p> <p>Examples:</p> <pre><code>import arguably\nfrom typing import Annotated\n\n@arguably.command\ndef process(\n    *,\n    verbose: Annotated[int, arguably.arg.count()],\n):\n\"\"\"\n    :param verbose: [-v] verbosity\n    \"\"\"\n    print(f\"{verbose=}\")\n\nif __name__ == \"__main__\":\n    arguably.run()\n</code></pre> <pre><code>user@machine:~$ python3 arg-count.py -vvvv\nverbose=4\n</code></pre>"},{"location":"api-reference/#arguably.arg.choices","title":"arguably.arg.choices","text":"<pre><code>arguably.arg.choices(*choices)\n</code></pre> <p>Specifies a fixed set of values that a parameter is allowed to be. If a parameter is an <code>enum.Enum</code> type, this logic is already used to restrict the inputs to be one of the enum entries.</p> <p>Parameters:</p> Name Type Description Default <code>*choices</code> <code>Union[str, enum.Enum]</code> <p>The allowed values. Must all be of the same type, and be compatible with the annotated type for this parameter.</p> <code>()</code> <p>Returns:</p> Type Description <code>mods.ChoicesModifier</code> <p>A value for use with <code>Annotated[]</code>, stating that this parameter has a fixed set of choices.</p> <p>Examples:</p> <pre><code>import arguably\nfrom typing import Annotated\n\n@arguably.command\ndef move(\n    direction: Annotated[str, arguably.arg.choices(\"left\", \"right\", \"up\", \"down\")]\n):\n\"\"\"An enum is usually recommended for cases like this\"\"\"\n    print(f\"{direction=}\")\n\nif __name__ == \"__main__\":\n    arguably.run()\n</code></pre> <pre><code>user@machine:~$ python3 arg-choices.py north\nusage: arg-choices.py [-h] {left,right,up,down}\narg-choices.py: error: argument direction: invalid choice: 'north' (choose from 'left', 'right', 'up', 'down')\n</code></pre>"},{"location":"api-reference/#arguably.arg.missing","title":"arguably.arg.missing","text":"<pre><code>arguably.arg.missing(omit_value)\n</code></pre> <p>Allows an option to be specified, but its value be omitted. In the case where the value is given, the value is used, but if it is omitted, <code>omit_value</code> will be used.</p> <p>Parameters:</p> Name Type Description Default <code>omit_value</code> <code>str</code> <p>The value that will be used if the flag is present, but the value is omitted.</p> required <p>Returns:</p> Type Description <code>mods.MissingArgDefaultModifier</code> <p>A value for use with <code>Annotated[]</code>, stating that this parameter has a special value if the flag is present, but no value is provided.</p> <p>Examples:</p> <pre><code>import arguably\nfrom pathlib import Path\nfrom typing import Annotated\n\n@arguably.command\ndef do_something(\n    *,\n    log: Annotated[Path | None, arguably.arg.missing(\"~/.log.txt\")] = None\n):\n    print(f\"{log=}\")\n\nif __name__ == \"__main__\":\n    arguably.run()\n</code></pre> <pre><code>user@machine:~$ python3 arg-missing.py\nlog=None\nuser@machine:~$ python3 arg-missing.py --log\nlog=PosixPath('~/.log.txt')\nuser@machine:~$ python3 arg-missing.py --log foo.log\nlog=PosixPath('foo.log')\n</code></pre>"},{"location":"api-reference/#arguably.arg.handler","title":"arguably.arg.handler","text":"<pre><code>arguably.arg.handler(func)\n</code></pre> <p>Causes a user-provided handler to be used to process the input string, instead of trying to process it using the types from type annotations.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[str], Any]</code> <p>The function to call to process the input string.</p> required <p>Returns:</p> Type Description <code>mods.HandlerModifier</code> <p>A value for use with <code>Annotated[]</code>, stating that this parameter has a specific handler to call.</p> <p>Examples:</p> <pre><code>import arguably\nfrom typing import Annotated\n\n@arguably.command\ndef handle_it(\n    version: Annotated[int, arguably.arg.handler(lambda s: int(s.split(\"-\")[-1]))] = None\n):\n    print(f\"{version=}\")\n\nif __name__ == \"__main__\":\n    arguably.run()\n</code></pre> <pre><code>user@machine:~$ python3 arg-handler.py Python-3\nversion=3\n</code></pre>"},{"location":"api-reference/#arguably.arg.builder","title":"arguably.arg.builder","text":"<pre><code>arguably.arg.builder()\n</code></pre> <p>Causes the arguably builder logic to be used instead of trying to instantiate the type from the input string.</p> <p>Returns:</p> Type Description <code>mods.BuilderModifier</code> <p>A value for use with <code>Annotated[]</code>, stating that this parameter should use the builder logic.</p> <p>Examples:</p> <pre><code>import arguably\nfrom dataclasses import dataclass\nfrom typing import Annotated\n\nclass Nic: ...\n\n@arguably.subtype(alias=\"tap\")\n@dataclass\nclass TapNic(Nic):\n    model: str\n\n@arguably.subtype(alias=\"user\")\n@dataclass\nclass UserNic(Nic):\n    hostfwd: str\n\n@arguably.command\ndef qemu_style(*, nic: Annotated[list[Nic], arguably.arg.builder()]):\n    print(f\"{nic=}\")\n\nif __name__ == \"__main__\":\n    arguably.run()\n</code></pre> <pre><code>user@machine:~$ ./build.py --nic tap,model=e1000 --nic user,hostfwd=tcp::10022-:22\nnic=[TapNic(model='e1000'), UserNic(hostfwd='tcp::10022-:22')]\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#prerequisites","title":"Prerequisites","text":"<p><code>poetry</code> is used for managing this project. To install poetry, follow this guide.</p>"},{"location":"contributing/#setup","title":"Setup","text":"<ol> <li>Clone the repository - <code>git clone git@github.com:treykeown/arguably.git</code></li> <li>Set up the project - <code>poetry install</code></li> <li>Activate the project virtualenv - <code>source .venv/bin/activate</code></li> <li>Install the pre-commit hooks - <code>pre-commit install</code></li> </ol> <p>That's it! You should be ready to make a change and open a pull request. Just remember to run <code>pytest</code> as you're developing to make sure everything works.</p> <p>I can help debug if you're having issues, just open a discussion.</p> <p>It's not necessary, but if you're using <code>pyenv</code>, you can install all the supported Python versions to make sure all tests pass before submitting your pull request. See the Testing section below.</p>"},{"location":"contributing/#pre-commit-hooks","title":"Pre-commit Hooks","text":"<p>If this is your first time using pre-commit hooks, all you need to know is that when you run <code>git commit</code>, a lot of tools are invoked to check the code. Notably absent is <code>pytest</code> - tests take quite a bit of time to run, and commiting should be fast. You'll need to make sure to run the tests yourself.</p> <p>If a pre-commit hook fails, it's because it just reformatted something (except for <code>mypy</code>, which will just complain and not fix itself). If something fails, you can just <code>git add</code> and <code>git commit</code> again with the same message. This will include the changes the pre-commit hook made to automatically reformat your code.</p>"},{"location":"contributing/#other-details","title":"Other Details","text":""},{"location":"contributing/#code-style","title":"Code Style","text":"<p>As with many projects, <code>black</code> is used to automatically format code. Its output is not always as clear as hand-formatting everything, but it's much faster and works well for projects with many contributors. You will not have to manually invoke <code>black</code>, it runs during the pre-commit hooks.</p> <p>If you do not type hint your functions, <code>mypy</code> will fail. Please add docstrings, but no need to document parameters (unless you want to!). A short description of each class or function is great.</p> <p>Sparse comments are appreciated!</p>"},{"location":"contributing/#linting","title":"Linting","text":"<p><code>ruff</code> and <code>mypy</code> are used for checking code correctness. These are automatically run as a part of the pre-commit hooks. If you want to invoke them manually, from the project root directory:</p> <ul> <li><code>ruff .</code></li> <li><code>mypy arguably/</code></li> </ul>"},{"location":"contributing/#testing","title":"Testing","text":"<p>Originally, tests were only conducted through directly running <code>pytest</code>. Now, in order to support multiple Python versions, <code>nox</code> is used to automatically test Python 3.8 through 3.11. Running all the tests for all versions takes a bit of time, so during normal development I directly run <code>pytest</code> and only run <code>nox</code> at the very end, before pushing. To invoke each, from the project root directory:</p> <ul> <li><code>pytest test --cov arguably --cov-report html</code> (will put a coverage report in the <code>htmlcov/</code> directory)</li> <li><code>nox</code> (automatically runs <code>noxfile.py</code>)</li> </ul> <p><code>nox</code> will require extra setup. You'll need to install Python versions 3.8 through 3.11 using <code>pyenv</code>:</p> <ul> <li><code>pyenv install 3.11 3.10 3.9 3.8</code></li> <li><code>pyenv global 3.11 3.10 3.9 3.8</code></li> </ul>"},{"location":"contributing/#building-docs","title":"Building Docs","text":"<p>I've been fighting <code>mkdocs</code>. I'm not sure that I'm winning.</p> <p>I ran into an issue where all the functions which were aliases of class methods weren't appearing in the automatically generated docs:</p> [source] <pre><code>run = context.run\nis_target = context.is_target\nerror = context.error\n</code></pre> <p>So I wrote a script, <code>mkdocs.py</code>. It temporarily swaps out the real <code>__init__.py</code> for a generated one which consists solely of skeletons of the functions and classes exposed in <code>__all__</code>. No code is in the generated file, only signatures and docstrings. The script also does a few other things:</p> <ul> <li>Strips the docstring from <code>__init__.py</code></li> <li>Copies in images from <code>etc/logo</code></li> <li>Tweaks <code>README.md</code> so that the light and dark mode images work</li> </ul> <p>I'm hoping to work on a proper <code>mkdocs</code> plugin one day to allow these sorts of tweaks without the steps I've taken here.</p> <p>If you can save me from my own madness here, please help me.</p>"},{"location":"contributing/#tldr","title":"TL;DR","text":"<p>Run <code>./mkdocs.py serve</code> to check the docs. <code>arguably</code> will not be usable as long as this is running, since I do some magic to work around a few <code>mkdocs</code> issues. Don't try to make a commit while <code>./mkdocs.py serve</code> is running.</p>"},{"location":"contributing/#making-releases","title":"Making Releases","text":"<p>I need to manually add a tag on GitHub for the new version, and it'll be automatically published on PyPI. At some point in the future, we'll have a changelog to go along with this.</p>"},{"location":"examples/","title":"Example Scripts","text":"<p>In the spirit of \"show, don't tell\", here are a few example scripts. Some of the scripts may be broken up to better show the code for a subcommand next to its output.</p>"},{"location":"examples/#hello-world","title":"Hello, world!","text":"<p>A \"Hello, world!\" script. Can accept a different name to greet, and has a <code>--shout</code> option. Because there is only one command, it's automatically selected - no need to specify a subcommand.</p> <p>If you're not familiar, the <code>*</code> works similarly to <code>*args</code> - it separates positional args from keyword-only args. In <code>arguably</code>, keyword-only args each appear as an <code>--option</code>.</p> [source] <p><pre><code>import arguably\n\n@arguably.command\ndef hello(name=\"world\", *, shout=False):\n\"\"\"\n    says hello to someone\n    Args:\n        name: {who} to greet\n        shout: will only use uppercase\n    \"\"\"\n    message = f\"Hello, {name}!\"\n    if shout:\n        message = message.upper()\n    print(message)\n\nif __name__ == \"__main__\":\n    arguably.run()\n</code></pre> <pre><code>user@machine:~$ python3 example-hello.py -h\nusage: example-hello.py [-h] [--shout] [WHO]\n\nsays hello to someone\n\npositional arguments:\n  WHO         who to greet (type: str, default: world)\n\noptions:\n  -h, --help  show this help message and exit\n  --shout     will only use uppercase (type: bool, default: False)\n</code></pre> <pre><code>user@machine:~$ python3 example-hello.py\nHello, world!\n</code></pre> <pre><code>user@machine:~$ python3 example-hello.py Python\nHello, Python!\n</code></pre> <pre><code>user@machine:~$ python3 example-hello.py --shout Python\nHELLO, PYTHON!\n</code></pre></p>"},{"location":"examples/#subcommands","title":"Subcommands","text":"<p>A simple script showing subcommands and multi-level subcommands being used. Outputs for each command are shown next to the its code.</p>"},{"location":"examples/#imports-and-hey_there","title":"Imports and <code>hey_there</code>","text":"[source] <p><pre><code>#!/usr/bin/env python3\n\"\"\"this docstring is the description for the script\"\"\"\n\nimport arguably\nimport builtins\n\n@arguably.command\ndef hey_there(first_name, last_name: str | None = None):\n\"\"\"\n    this will say hello to someone\n\n    arguments without annotations (`first_name`) default to `str`\n        ... unless the type can be inferred from their default value\n    any union with `None` is removed, so `last_name` is parsed as `str`\n\n    Args:\n        first_name: the {first} name of the person to greet\n        last_name: their {last} name\n    \"\"\"\n    if last_name is None:\n        full_name = first_name\n    else:\n        full_name = f\"{first_name} {last_name}\"\n    print(f\"Hello, {full_name}!\")\n</code></pre> <pre><code>user@machine:~$ python3 simple.py hey-there -h\nusage: simple.py hey-there [-h] FIRST [LAST]\n\nthis will say hello to someone\n\npositional arguments:\n  FIRST       the first name of the person to greet (type: str)\n  LAST        their last name (type: str, default: None)\n\noptions:\n  -h, --help  show this help message and exit\n</code></pre> <pre><code>user@machine:~$ python3 simple.py hey-there Monty\nHello, Monty!\n</code></pre> <pre><code>user@machine:~$ python3 simple.py hey-there Monty Python\nHello, Monty Python!\n</code></pre></p>"},{"location":"examples/#good","title":"<code>good</code>","text":"<p><code>good</code> has two subcommands. The <code>-s/--shout</code> option is able to be passed to <code>good</code> any time one of these subcommands is invoked.</p> <p><pre><code>@arguably.command(alias=\"g\")\ndef good(*, shout=False):\n\"\"\"\n    this is a command with two subcommands\n\n    everything after the `*` appears as an `--option`\n    `shout` is inferred to be a `bool` because of its default value\n        `bool` `--option`s take no value by design\n\n    Args:\n        shout: [-s] will shout out the greeting\n    \"\"\"\n    if shout:\n        # All prints are now UPPERCASE\n        global print\n        print = lambda msg: builtins.print(msg.upper())\n</code></pre> <pre><code>user@machine:~$ python3 simple.py good -h\nusage: simple.py good [-h] [-s] command ...\n\nthis is a command with two subcommands\n\npositional arguments:\n  command\n    morning    Greet someone early in the day\n    night      Say goodbye at night\n\noptions:\n  -h, --help   show this help message and exit\n  -s, --shout  will shout out the greeting (type: bool, default: False)\n</code></pre></p>"},{"location":"examples/#good__morning","title":"<code>good__morning</code>","text":"<p><pre><code>@arguably.command\ndef good__morning(name):\n\"\"\"Greet someone early in the day\"\"\"\n    print(f\"Good morning, {name}!\")\n</code></pre> <pre><code>user@machine:~$ python3 simple.py good -s morning Monty\nGOOD MORNING, MONTY!\n</code></pre></p>"},{"location":"examples/#good__night","title":"<code>good__night</code>","text":"<p><pre><code>@arguably.command\ndef good__night(name):\n\"\"\"Say goodbye at night\"\"\"\n    print(f\"Good night, {name}!\")\n</code></pre> <pre><code>user@machine:~$ python3 simple.py good night Python\nGood night, Python!\n</code></pre></p>"},{"location":"examples/#arguablyrun","title":"<code>arguably.run()</code>","text":"<p><pre><code>if __name__ == \"__main__\":\n    arguably.run()\n</code></pre> <pre><code>user@machine:~$ python3 simple.py\nusage: simple.py [-h] command ...\n\nthis docstring is the description for the script\n\npositional arguments:\n  command\n    hey-there  this will say hello to someone\n    good (g)   this is a command with two subcommands\n\noptions:\n  -h, --help   show this help message and exit\n</code></pre></p>"},{"location":"examples/#one-of-everything","title":"One of everything","text":"<p>This script includes one of every feature. <code>arguably</code> is designed so that you don't have to reach for the tools hidden behind <code>Annotated[]</code> except in special cases, but this script makes heavy use of them.</p> <p>It's a long script, so it's periodically broken up to show the results on the CLI.</p>"},{"location":"examples/#imports-and-__root__","title":"Imports and <code>__root__</code>","text":"[source] <pre><code>#!/usr/bin/env python3\n\"\"\"\nA demo script to show all features\n\"\"\"\n\nimport enum\nimport operator\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom typing import Annotated\n\nimport arguably\n\n# used if version_flag is set\n__version__ = \"1.0.0\"\n\n@arguably.command\ndef __root__(*, verbose: Annotated[int, arguably.arg.count()] = 0):\n\"\"\"\n    __root__ is always called first, before any subcommand.\n    It's also run if no subcommand is specified.\n\n    Args:\n        verbose: [-v] the verbosity - flag occurrences are counted\n    \"\"\"\n    print(f\"Verbosity: {verbose}\")\n    if not arguably.is_target():\n        return\n    print(\"__root__ is the target!\")\n</code></pre> <pre><code>user@machine:~$ ./everything.py -vvvv\nVerbosity: 4\n__root__ is the target!\n</code></pre>"},{"location":"examples/#add","title":"<code>add</code>","text":"<p><pre><code>@arguably.command\ndef add(\n    coords: tuple[int, int],\n    *values: Annotated[int, arguably.arg.required()],\n    include_z: bool = False,\n):\n\"\"\"\n    this is the CLI description for this command\n    Args:\n        coords: some coordinates {X,Y}\n        *values: scalar {value}s to add to the coords, requires one or more\n        include_z: [-z] whether to include a value for Z\n    \"\"\"\n    print(f\"Coordinates: {coords}\")\n    if include_z:\n        x, y = coords\n        z = 0\n        coords = (x, y, z)\n    for value in values:\n        value_arr = (value,) * len(coords)\n        coords = tuple(map(operator.add, coords, value_arr))\n        print(f\"Added {value}: {coords}\")\n    print(f\"Result: {coords}\")\n</code></pre> <pre><code>user@machine:~$ ./everything.py add -h\nusage: kitchen-sink add [-h] [-z] X,Y VALUE [VALUE ...]\n\nthis is the CLI description for this command\n\npositional arguments:\n  X,Y              some coordinates X,Y (type: (int,int))\n  VALUE            scalar values to add to the coords, requires one or more (type: int)\n\noptions:\n  -h, --help       show this help message and exit\n  -z, --include-z  whether to include a value for Z (type: bool, default: False)\n</code></pre> <pre><code>user@machine:~$ ./everything.py add -z 5,5 1 2 3 4\nVerbosity: 0\nCoordinates: (5, 5)\nAdded 1: (6, 6, 1)\nAdded 2: (8, 8, 3)\nAdded 3: (11, 11, 6)\nAdded 4: (15, 15, 10)\nResult: (15, 15, 10)\n</code></pre></p>"},{"location":"examples/#chmod","title":"<code>chmod</code>","text":"<p><pre><code>class Permissions(enum.Flag):\n    READ = 4\n\"\"\"[-r] allows for reads\"\"\"\n    WRITE = 2\n\"\"\"[-w] allows for writes\"\"\"\n    EXECUTE = 1\n\"\"\"[-x] allows for execution\"\"\"\n\n@arguably.command\ndef chmod(file: Path, *, flags: Permissions = Permissions(0)):\n\"\"\"\n    flags break down into multiple --options, one for each flag member.\n    the docstring for each flag member is used.\n    Args:\n        file: the file to modify\n        flags: permission flags\n    \"\"\"\n    print(f\"{file=}\", f\"{flags=}\")\n</code></pre> <pre><code>user@machine:~$ ./everything.py chmod -h\nusage: kitchen-sink chmod [-h] [-r] [-w] [-x] file\n\nflags break down into multiple --options, one for each flag member.\n\npositional arguments:\n  file           the file to modify (type: Path)\n\noptions:\n  -h, --help     show this help message and exit\n  -r, --read     allows for reads\n  -w, --write    allows for writes\n  -x, --execute  allows for execution\n</code></pre> <pre><code>user@machine:~$ ./everything.py chmod foo.exe -rwx\nVerbosity: 0\nfile=PosixPath('foo.exe') flags=&lt;Permissions.READ|WRITE|EXECUTE: 7&gt;\n</code></pre></p>"},{"location":"examples/#move","title":"<code>move</code>","text":"<p><pre><code>class Direction(enum.Enum):\n    UP = (0, 1)\n    DOWN = (0, -1)\n    LEFT = (-1, 0)\n    RIGHT = (1, 0)\n\n@arguably.command\ndef move(direction: Direction):\n\"\"\"\n    enum values are entered by the enum value name\n    Args:\n        direction: the direction to move\n    \"\"\"\n    dx, dy = direction.value\n    print(f\"Will move {dx}, {dy}\")\n</code></pre> <pre><code>user@machine:~$ ./everything.py move -h\nusage: kitchen-sink move [-h] {up,down,left,right}\n\nenum values are entered by the enum value name\n\npositional arguments:\n  {up,down,left,right}  the direction to move (type: Direction)\n\noptions:\n  -h, --help            show this help message and exit\n</code></pre> <pre><code>user@machine:~$ ./everything.py move up\nVerbosity: 0\nWill move 0, 1\n</code></pre></p>"},{"location":"examples/#make","title":"<code>make</code>","text":"<p><pre><code>@arguably.command\ndef make(\n    target: Annotated[str, arguably.arg.choices(\"build\", \"install\", \"clean\")],\n    *,\n    log: Annotated[Path | None, arguably.arg.missing(\"~/.log.txt\")] = None,\n):\n\"\"\"\n    arguably.arg.choices restricts input values\n    arguably.arg.missing provides a value if the flag is specified but value omitted\n    Args:\n        target: the command to send to `make`\n        log: the path to log, if any\n    \"\"\"\n    print(f\"Running `make {target}`\")\n    if log is None:\n        print(\"Will not log\")\n    else:\n        print(f\"Logging to {log}\")\n</code></pre> <pre><code>user@machine:~$ ./everything.py make -h\nusage: kitchen-sink make [-h] [--log [LOG]] {build,install,clean}\n\narguably.arg.choices restricts input values\n\npositional arguments:\n  {build,install,clean}  the command to send to `make` (type: str)\n\noptions:\n  -h, --help             show this help message and exit\n  --log [LOG]            the path to log, if any (type: Path, default: None)\n</code></pre> <pre><code>user@machine:~$ ./everything.py make build\nVerbosity: 0\nRunning `make build`\nWill not log\n</code></pre> <pre><code>user@machine:~$ ./everything.py make build --log\nVerbosity: 0\nRunning `make build`\nLogging to ~/.log.txt\n</code></pre> <pre><code>user@machine:~$ ./everything.py make build --log foo.log\nVerbosity: 0\nRunning `make build`\nLogging to foo.log\n</code></pre></p>"},{"location":"examples/#arg","title":"<code>arg</code>","text":"<p><pre><code>@arguably.command\ndef arg():\n\"\"\"\n    this has two subcommands. a double underscore __ is used when a space would appear\n      * arg__handler -&gt; \"arg handler\"\n      * arg__builder -&gt; \"arg builder\"\n    \"\"\"\n    print(\"Hello from arg()!\")\n    if arguably.is_target():\n        print(\"arg() is the target!\")\n</code></pre> <pre><code>user@machine:~$ ./everything.py arg -h\nusage: kitchen-sink arg [-h] command ...\n\nthis has two subcommands. a double underscore __ is used when a space would appear\n\npositional arguments:\n  command\n    handler   runs a custom handler for input\n    builder   builds a complex class - can pick between subtypes of class\n\noptions:\n  -h, --help  show this help message and exit\n</code></pre> <pre><code>user@machine:~$ ./everything.py arg\nVerbosity: 0\nHello from arg()!\narg() is the target!\n</code></pre></p>"},{"location":"examples/#arg__handler","title":"<code>arg__handler</code>","text":"<p><pre><code>@arguably.command\ndef arg__handler(\n    version: Annotated[str, arguably.arg.handler(lambda s: s.removeprefix(\"Python-\"))]\n):\n\"\"\"\n    runs a custom handler for input\n    arguably.arg.handler allows for arbitrary functions to handle inputs\n    this one removes a prefix of \"Python-\" before passing the value along\n    Args:\n        version: Python version, like 3.11\n    \"\"\"\n    print(f\"Python version: {version}\")\n</code></pre> <pre><code>user@machine:~$ ./everything.py arg handler -h\nusage: kitchen-sink arg handler [-h] version\n\nruns a custom handler for input\n\npositional arguments:\n  version     Python version, like 3.11 (type: str)\n\noptions:\n  -h, --help  show this help message and exit\n</code></pre> <pre><code>user@machine:~$ ./everything.py arg handler Python-3.10\nVerbosity: 0\nHello from arg()!\nPython version: 3.10\n</code></pre></p>"},{"location":"examples/#arg__builder","title":"<code>arg__builder</code>","text":"<p><pre><code>class Nic: ...\n\n@arguably.subtype(alias=\"tap\")\n@dataclass\nclass TapNic(Nic):\n    model: str\n\n@arguably.subtype(alias=\"user\")\n@dataclass\nclass UserNic(Nic):\n    hostfwd: str\n\n@arguably.command\ndef arg__builder(\n    *,\n    nic: Annotated[list[Nic], arguably.arg.builder()]\n):\n\"\"\"\n    builds a complex class - can pick between subtypes of class\n    Args:\n        nic: network interfaces - will build subclasses of `Nic`\n    \"\"\"\n    print(f\"Built nics: {nic}\")\n</code></pre> <pre><code>user@machine:~$ ./everything.py arg builder -h\nusage: kitchen-sink arg builder [-h] --nic NIC\n\nbuilds a complex class - can pick between subtypes of class\n\noptions:\n  -h, --help  show this help message and exit\n  --nic NIC   network interfaces - will build subclasses of `Nic` (type: list[Nic])\n</code></pre> <pre><code>user@machine:~$ ./everything.py -vvv arg builder --nic tap,model=e1000 --nic user,hostfwd=tcp::10022-:22\nVerbosity: 3\nHello from arg()!\nBuilt nics: [TapNic(model='e1000'), UserNic(hostfwd='tcp::10022-:22')]\n</code></pre></p>"},{"location":"examples/#list_","title":"<code>list_</code>","text":"<p><pre><code>@arguably.command\ndef list_(files: list[Path], *, output: list[str]):\n\"\"\"\n    lists are supported and use a comma to separate inputs\n    an empty list is a single dash `-`\n    if a list appears as an `--option`, it can be repeated\n    Args:\n        files: input files\n        output: outputs\n    \"\"\"\n    for file in files:\n        print(f\"Resolved path: {file.resolve()}\")\n    for out in output:\n        print(f\"Will output to {out}\")\n</code></pre> <pre><code>user@machine:~$ ./everything.py list -h\nusage: kitchen-sink list [-h] --output OUTPUT files\n\nlists are supported and use a comma to separate inputs\n\npositional arguments:\n  files            input files (type: list[Path])\n\noptions:\n  -h, --help       show this help message and exit\n  --output OUTPUT  outputs (type: list[str])\n</code></pre> <pre><code>user@machine:~$ ./everything.py list foo.txt,bar.bat --output wifi0,en0 --output en1\nVerbosity: 0\nResolved path: .../arguably/etc/scripts/foo.txt\nResolved path: .../arguably/etc/scripts/bar.bat\nWill output to wifi0\nWill output to en0\nWill output to en1\n</code></pre></p>"},{"location":"examples/#arguablyrun_1","title":"<code>arguably.run()</code>","text":"<p><pre><code>if __name__ == \"__main__\":\n    arguably.run(name=\"kitchen-sink\", version_flag=True)\n</code></pre> <pre><code>user@machine:~$ ./everything.py -h\nusage: kitchen-sink [-h] [--version] [-v] command ...\n\nA demo script to show all features\n\npositional arguments:\n  command\n    add          this is the CLI description for this command\n    chmod        flags break down into multiple --options, one for each flag member.\n    move         enum values are entered by the enum value name\n    make         arguably.arg.choices restricts input values\n    arg          this has two subcommands. a double underscore __ is used when a space would appear\n    list         lists are supported and use a comma to separate inputs\n\noptions:\n  -h, --help     show this help message and exit\n  --version      show program's version number and exit\n  -v, --verbose  the verbosity - flag occurrences are counted (type: int, default: 0)\n</code></pre> <pre><code>user@machine:~$ ./everything.py --version\nkitchen-sink 1.0.0\n</code></pre></p>"},{"location":"why/","title":"Why <code>arguably</code>?","text":"<p>With plenty of other tools out there, why use <code>arguably</code>? Aren't other ones (<code>click</code>, <code>typer</code>, etc) good enough?</p> <p>The short answer is: yeah, probably! Python already has great tools for building CLIs. But they still make you write quite a bit of code. That's where <code>arguably</code> comes in.</p>"},{"location":"why/#an-unobtrusive-api","title":"An unobtrusive API","text":"<p>What <code>arguably</code> does best is get out of your way.</p> <p>Set up a function signature and docstring, annotate with <code>@arguably.command</code>, and you've set up a CLI. That's it, that's the API.</p> <p>No need for <code>typer.Option()</code> or <code>click.option()</code>. That's because <code>arguably</code> was built from the ground-up with a focus on providing most of the features of these libraries (and a few extra) with few code changes necessary on your part. Because of this, your CLI functions still look and behave like regular functions.</p> [source] <pre><code>#!/usr/bin/env python3\nimport arguably\n\n@arguably.command\ndef some_function(required, not_required=2, *others: int, option: float = 3.14):\n\"\"\"\n    this function is on the command line!\n\n    Args:\n        required: a required argument\n        not_required: this one isn't required, since it has a default value\n        *others: all the other positional arguments go here\n        option: [-x] keyword-only args are options, short name is in brackets\n    \"\"\"\n    print(f\"{required=}, {not_required=}, {others=}, {option=}\")\n\nif __name__ == \"__main__\":\n    arguably.run()\n</code></pre> <pre><code>user@machine:~$ ./intro.py -h\nusage: intro.py [-h] [-x OPTION] required [not-required] [others ...]\n\nthis function is on the command line!\n\npositional arguments:\n  required             a required argument (type: str)\n  not-required         this one isn't required, since it has a default value (type: int, default: 2)\n  others               all the other positional arguments go here (type: int)\n\noptions:\n  -h, --help           show this help message and exit\n  -x, --option OPTION  keyword-only args are options, short name is in brackets (type: float, default: 3.14)\n</code></pre> <pre><code>&gt;&gt;&gt; from intro import some_function\n&gt;&gt;&gt; some_function(\"asdf\", 0, 7, 8, 9, option=2.71)\nrequired='asdf', not_required=0, others=(7, 8, 9), option=2.71\n</code></pre> <pre><code>user@machine:~$ ./intro.py \"asdf\" 0 7 8 9 --option 2.71\nrequired='asdf', not_required=0, others=(7, 8, 9), option=2.71\n</code></pre>"},{"location":"why/#zero-effort-cli","title":"Zero-effort CLI","text":"<p>Taking inspiration from Python Fire, <code>arguably</code> is also able to execute your script directly, requiring no code changes - just run <code>python3 -m arguably your_script.py</code> to expose all functions (and your class <code>@classmethod</code>, <code>@staticmethod</code>, and <code>__init__</code> methods) on the CLI.</p> [source] <pre><code>\"\"\"this is the docstring for the whole script\"\"\"\n__version__ = \"2.3.4\"  # __version__ will be used if present\n\ndef hello(name) -&gt; None:\n\"\"\"\n    this is hello's docstring\n    Args:\n        name: argument docstrings are automatically used\n    \"\"\"\n    print(f\"Hello, {name}!\")\n\ndef goodbye(name) -&gt; None:\n\"\"\"any function from a script can be called\"\"\"\n    print(f\"Goodbye, {name}!\")\n\nclass SomeClass:\n    def __init__(self):\n\"\"\"so can any __init__ for objects defined in the script\"\"\"\n        print(\"__init__\")\n\n    @staticmethod\n    def func_static(string=\"Monty\"):\n\"\"\"a @staticmethod on a class can be called\"\"\"\n        print(f\"{string=}\")\n\n    @classmethod\n    def func_cls(cls, number=1):\n\"\"\"so can a @classmethod\"\"\"\n        print(f\"{number=}\")\n\n    def normal(self) -&gt; None:\n\"\"\"but normal methods can't\"\"\"\n        print(\"instance method\")\n</code></pre> <pre><code>user@machine:~$ python3 -m arguably party-trick.py -h\nusage: party-trick [-h] [--version] command ...\n\nthis is the docstring for the whole script\n\npositional arguments:\n  command\n    hello                   this is hello's docstring\n    goodbye                 any function from a script can be called\n    some-class              so can any __init__ for objects defined in the script\n    some-class.func-static  a @staticmethod on a class can be called\n    some-class.func-cls     so can a @classmethod\n\noptions:\n  -h, --help                show this help message and exit\n  --version                 show program's version number and exit\n</code></pre> <pre><code>user@machine:~$ python3 -m arguably party-trick.py hello -h\nusage: party-trick hello [-h] name\n\nthis is hello's docstring\n\npositional arguments:\n  name        argument docstrings are automatically used (type: str)\n\noptions:\n  -h, --help  show this help message and exit\n</code></pre> <pre><code>user@machine:~$ python3 -m arguably party-trick.py hello world\nHello, world!\n</code></pre>"},{"location":"why/#a-comparison-with-typer","title":"A comparison with <code>typer</code>","text":"<p>A quick comparison with a <code>typer</code> CLI is below. This is taken from the <code>databooks</code> project.</p> <p>Warning</p> <p>The design for the config interface shown here for <code>arguably</code> isn't yet finalized and is still being implemented. Development is tracked in https://github.com/treykeown/arguably/issues/13.</p>"},{"location":"why/#the-typer-implementation","title":"The <code>typer</code> implementation","text":"[source] <pre><code>app = Typer()\n\n...\n\n@app.command(add_help_option=False)\ndef show(\n    paths: List[Path] = Argument(\n        ..., is_eager=True, help=\"Path(s) of notebook files with conflicts\"\n    ),\n    ignore: List[str] = Option([\"!*\"], help=\"Glob expression(s) of files to ignore\"),\n    export: Optional[ImgFmt] = Option(\n        None,\n        \"--export\",\n        \"-x\",\n        help=\"Export rich outputs as a string.\",\n    ),\n    pager: bool = Option(\n        False, \"--pager\", \"-p\", help=\"Use pager instead of printing to terminal\"\n    ),\n    verbose: bool = Option(\n        False, \"--verbose\", \"-v\", help=\"Increase verbosity for debugging\"\n    ),\n    multiple: bool = Option(False, \"--yes\", \"-y\", help=\"Show multiple files\"),\n    config: Optional[Path] = Option(\n        None,\n        \"--config\",\n        \"-c\",\n        is_eager=True,\n        callback=_config_callback,\n        resolve_path=True,\n        exists=True,\n        help=\"Get CLI options from configuration file\",\n    ),\n    help: Optional[bool] = Option(\n        None,\n        \"--help\",\n        is_eager=True,\n        callback=_help_callback,\n        help=\"Show this message and exit\",\n    ),\n) -&gt; None:\n\"\"\"Show rich representation of notebook.\"\"\"\n    ...\n\n...\n\napp(prog_name=\"databooks\")\n</code></pre>"},{"location":"why/#rewritten-with-arguably","title":"Rewritten with <code>arguably</code>","text":"<pre><code>@arguably.command\ndef show(\n    *paths: Path,\n    ignore: List[str] = [\"!*\"],\n    export: Optional[ImgFmt] = None,\n    pager: bool = False,\n    verbose: bool = False,\n    multiple: bool = False,\n) -&gt; None:\n\"\"\"\n    Show rich representation of notebook.\n    Args:\n        *paths: Path(s) of notebook files with conflicts\n        ignore: Glob expression(s) of files to ignore\n        export: [-x] Export rich outputs as a string.\n        pager: [-p] Use pager instead of printing to terminal\n        verbose: [-v] Increase verbosity for debugging\n        multiple: [-y/--yes] Show multiple files\n    \"\"\"\n    ...\n\n...\n\narguably.run(name=\"databooks\", version_flag=True, config_flag=(\"-c\", \"--config\"))\n</code></pre> <ul> <li><code>--help</code> is eagerly evaluated by default in <code>arguably</code>, so no separate argument is required.</li> <li>Aliases for options appear first in the docstring, like <code>[-x]</code> for <code>export</code>.</li> <li>The function still looks and behaves the same:<ul> <li>No need to assign <code>typer.Option()</code> as the default value for parameters</li> <li>No need to put <code>Annotated[]</code> as your argument type, except in special cases.</li> </ul> </li> </ul> <p><code>arguably</code> doesn't currently cover all the features that other frameworks do. It's designed with a focus on a minimal API covering most use cases for most CLIs.</p>"},{"location":"tutorial/intro/","title":"Introduction","text":"<p>When it comes to <code>arguably</code>, the most important things to know are:</p> <ul> <li><code>@arguably.command</code> makes a function appear on the CLI</li> <li><code>arguably.run()</code> parses the CLI arguments and calls the decorated functions</li> </ul>"},{"location":"tutorial/intro/#hello-world","title":"Hello, world!","text":"<p>Here's a simple \"Hello, world!\" script:</p> [source] <pre><code>import arguably\n\n@arguably.command\ndef hello(name):\n    print(f\"Hello, {name}!\")\n\nif __name__ == \"__main__\":\n    arguably.run()\n</code></pre> <p><pre><code>user@machine:~$ python3 hello-1.py Python\nHello, Python!\n</code></pre> <pre><code>user@machine:~$ python3 hello-1.py -h\nusage: hello-1.py [-h] name\n\npositional arguments:\n  name        (type: str)\n\noptions:\n  -h, --help  show this help message and exit\n</code></pre></p> <p>Because <code>name</code> is a required argument for the <code>hello()</code> function, it's also a required argument on the CLI. If the script is run without giving a <code>name</code>, it prints a message stating that the argument is required:</p> <pre><code>user@machine:~$ python3 hello-1.py\nusage: hello-1.py [-h] name\nhello-1.py: error: the following arguments are required: name\n</code></pre> <p>Note</p> <p>If desired, <code>async</code> functions are also supported.  [source] <pre><code>import arguably\nimport asyncio\n\n@arguably.command\nasync def hello(name):\n    await asyncio.sleep(1)\n    print(f\"Hello, {name}!\")\n\nif __name__ == \"__main__\":\n    arguably.run()\n</code></pre> <pre><code>user@machine:~$ python3 hello-async-1.py Python\nHello, Python!\n</code></pre></p>"},{"location":"tutorial/intro/#optional-arguments","title":"Optional arguments","text":"<p>To make an argument optional, give it a default value.</p> [source] <pre><code>@arguably.command\ndef hello(name=\"world\"):\n    print(f\"Hello, {name}!\")\n</code></pre> <p><pre><code>user@machine:~$ python3 hello-2.py\nHello, world!\n</code></pre> <pre><code>user@machine:~$ python3 hello-2.py Python\nHello, Python!\n</code></pre> <pre><code>user@machine:~$ python3 hello-2.py -h\nusage: hello-2.py [-h] [name]\n\npositional arguments:\n  name        (type: str, default: world)\n\noptions:\n  -h, --help  show this help message and exit\n</code></pre></p>"},{"location":"tutorial/intro/#adding-an-option","title":"Adding an <code>[--option]</code>","text":"<p>To make an <code>--option</code> instead of a positional argument, use keyword-only arguments. These are the arguments that appear after the <code>*</code> in the parameter list.</p> [source] <pre><code>@arguably.command\ndef hello(*, name=\"world\"):\n    print(f\"Hello, {name}!\")\n</code></pre> <pre><code>&gt;&gt;&gt; @arguably.command\n... def hello(*, name=\"world\"):\n...     print(f\"Hello, {name}!\")\n...\n&gt;&gt;&gt; hello()\nHello, world!\n&gt;&gt;&gt; hello(\"Python\")\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: hello() takes 0 positional arguments but 1 was given\n&gt;&gt;&gt; hello(name=\"Python\")\nHello, Python!\n</code></pre> <p><pre><code>user@machine:~$ python3 hello-3.py -h\nusage: hello-3.py [-h] [--name NAME]\n\noptions:\n  -h, --help   show this help message and exit\n  --name NAME  (type: str, default: world)\n</code></pre> <pre><code>user@machine:~$ python3 hello-3.py --name Python\nHello, Python!\n</code></pre></p>"},{"location":"tutorial/intro/#flexible-number-of-args","title":"Flexible number of args","text":"<p>To take in a variable number of positional arguments, use <code>*args</code>:</p> [source] <pre><code>import arguably\n\n@arguably.command\ndef hello(*from_, name=\"world\"):\n    print(f\"Hello, {name}!\")\n    print(f\"From: {', '.join(from_)}\")\n\nif __name__ == \"__main__\":\n    arguably.run()\n</code></pre> <p><pre><code>user@machine:~$ python3 hello-4.py -h\nusage: hello-4.py [-h] [--name NAME] [from ...]\n\npositional arguments:\n  from         (type: str)\n\noptions:\n  -h, --help   show this help message and exit\n  --name NAME  (type: str, default: world)\n</code></pre> <pre><code>user@machine:~$ python3 hello-4.py Graham John Terry Eric Terry Michael --name Python\nHello, Python!\nFrom: Graham, John, Terry, Eric, Terry, Michael\n</code></pre></p> <p>To require at least one input to <code>*args</code>, use <code>arguably.arg.required()</code>.</p>"},{"location":"tutorial/intro/#adding-help-messages","title":"Adding help messages","text":"<p>To add help messages to parameters, add a docstring. It can be any of the major formats: reStructuredText (Sphinx), Google, Numpydoc, or Epydoc. We'll use Google's style for this example.</p> [source] <pre><code>@arguably.command\ndef hello(*from_, name=\"world\"):\n\"\"\"\n    this will say hello to someone\n\n    Args:\n        from_: greetings are sent from these people\n        name: is who this will greet\n    \"\"\"\n    print(f\"Hello, {name}!\")\n    print(f\"From: {', '.join(from_)}\")\n</code></pre> <pre><code>user@machine:~$ python3 hello-5.py -h\nusage: hello-5.py [-h] [--name NAME] [from ...]\n\nthis will say hello to someone\n\npositional arguments:\n  from         greetings are sent from these people (type: str)\n\noptions:\n  -h, --help   show this help message and exit\n  --name NAME  is who this will greet (type: str, default: world)\n</code></pre>"},{"location":"tutorial/intro/#option-names","title":"Option names","text":"<p>By default, any <code>--options</code> will have a long name which is a normalized version of their Python name. Options do not have a short name by default.</p> <p>Option names can be controlled by prefixing their description with a value in square brackets <code>[]</code>:</p> <ul> <li><code>[-t]</code> \u2192 <code>-t</code> is the short name</li> <li><code>[--to]</code> \u2192 <code>--to</code> is the long name</li> <li><code>[-t/--to]</code> \u2192 <code>-t</code> is the short name and <code>--to</code> is the long name</li> <li><code>[-t/]</code> \u2192 <code>-t</code> is the short name, the long name is removed.</li> </ul> [source] <pre><code>@arguably.command\ndef hello(*, from_=\"me\", name=\"world\"):\n\"\"\"\n    this will say hello to someone\n\n    Args:\n        from_: [-f/] the sender of these greetings\n        name: [-t/--to] the receiver of these greetings\n    \"\"\"\n    print(f\"Hello, {name}!\")\n    print(f\"From: {from_}\")\n</code></pre> <pre><code>user@machine:~$ python3 etc/scripts/hello-6.py -h\nusage: hello-6.py [-h] [-f FROM] [-t TO]\n\nthis will say hello to someone\n\noptions:\n  -h, --help   show this help message and exit\n  -f FROM      the sender of these greetings (type: str, default: me)\n  -t, --to TO  the receiver of these greetings (type: str, default: world)\n</code></pre>"},{"location":"tutorial/intro/#metavars","title":"Metavars","text":"<p>A metavar is what gets printed in the usage string to represent the user-provided value. More explanation for that here.</p> <p>By default, the metavar for any argument is the uppercase version of its name. To change the metavar, wrap any word in its description in curly braces <code>{}</code>. Tuples can specify one value or a number of comma-separated values equal to the tuple length.</p> <ul> <li><code>{who}</code> \u2192 <code>WHO</code> is the metavar</li> <li><code>{x,y,z}</code> \u2192 <code>X</code>, <code>Y</code>, and <code>Z</code> are the metavars for a tuple of length 3</li> </ul> [source] <pre><code>@arguably.command\ndef hello(*, from_=\"me\", name=\"world\"):\n\"\"\"\n    this will say hello to someone\n\n    Args:\n        from_: [-f/] the {sender} of these greetings\n        name: [-t/--to] the {receiver} of these greetings\n    \"\"\"\n    print(f\"Hello, {name}!\")\n    print(f\"From: {from_}\")\n</code></pre> <pre><code>user@machine:~$ python3 etc/scripts/hello-7.py -h\nusage: hello-7.py [-h] [-f SENDER] [-t RECEIVER]\n\nthis will say hello to someone\n\noptions:\n  -h, --help         show this help message and exit\n  -f SENDER          the sender of these greetings (type: str, default: me)\n  -t, --to RECEIVER  the receiver of these greetings (type: str, default: world)\n</code></pre> <p>Compare the last line with how it was before:</p> <pre><code>Before:  -t, --to TO  the receiver of these greetings (type: str, default: world)\nAfter:   -t, --to RECEIVER  the receiver of these greetings (type: str, default: world)\n</code></pre>"},{"location":"tutorial/intro/#summary","title":"Summary","text":"<p><code>arguably</code> looks at all decorated functions and maps their arguments from Python to the CLI.</p> <pre><code>@arguably.command\ndef some_function(required, not_required=2, *others: int, option: float = 3.14):\n    ...\n</code></pre> <pre><code>user@machine:~$ ./intro.py -h\nusage: intro.py [-h] [-x OPTION] required [not-required] [others ...]\n...\n</code></pre> This Python ... ... becomes this on the CLI. positional args, no default <code>required</code> positional CLI args, required <code>required</code> positional args, with default <code>not_required=2</code> positional CLI args, optional <code>[not-required]</code> positional args, variadic <code>*others</code> any extra positional CLI args <code>[others ...]</code> keyword-only arguments <code>option</code> command-line options <code>[-x OPTION]</code> <p>Docstrings are used for command and argument help messages. They can also:</p> <ul> <li>Change option names:<ul> <li>Set the short name with <code>[-n]</code></li> <li>Change the long name with <code>[--name]</code></li> <li>Set the short and long names with <code>[-n/--name]</code></li> <li>Set the short name and remove the long name with <code>[-n/]</code></li> </ul> </li> <li>Change the metavar of an argument to <code>SOMETHING</code> by wrapping a word in curly braces: <code>{something}</code></li> </ul>"},{"location":"tutorial/subcommands/","title":"Subcommands","text":""},{"location":"tutorial/subcommands/#introduction","title":"Introduction","text":"<p>Marking multiple functions with <code>@arguably.command</code> will make them show up as subcommands on the CLI:</p> [source] <pre><code>import arguably\n\n@arguably.command\ndef hello(name):\n\"\"\"this will say hello to someone\"\"\"\n    print(f\"Hello, {name}!\")\n\n@arguably.command\ndef goodbye(name):\n\"\"\"this will say goodbye to someone\"\"\"\n    print(f\"Goodbye, {name}!\")\n\nif __name__ == \"__main__\":\n    arguably.run()\n</code></pre> <p><pre><code>user@machine:~$ python3 goodbye-1.py -h\nusage: goodbye-1.py [-h] command ...\n\npositional arguments:\n  command\n    hello     this will say hello to someone\n    goodbye   this will say goodbye to someone\n\noptions:\n  -h, --help  show this help message and exit\n</code></pre> <pre><code>user@machine:~$ python3 goodbye-1.py hello Python\nHello, Python!\n</code></pre> <pre><code>user@machine:~$ python3 goodbye-1.py goodbye Python\nGoodbye, Python!\n</code></pre></p>"},{"location":"tutorial/subcommands/#name-normalization","title":"Name normalization","text":"<p>Function names are first converted to lowercase. Single underscores <code>_</code> in a function name are converted to a dash <code>-</code>. Also, any leading or trailing underscores are stripped.</p> <ul> <li><code>def FOOBAR()</code> \u2192 <code>foobar</code></li> <li><code>def foo_bar():</code> \u2192 <code>foo-bar</code></li> <li><code>def list_():</code> \u2192 <code>list</code></li> <li><code>def _asdf():</code> \u2192 <code>asdf</code></li> <li><code>def __foo__():</code> \u2192 <code>foo</code></li> <li><code>def ___really_really_long_name():</code> \u2192 <code>really-really-long-name</code></li> </ul>"},{"location":"tutorial/subcommands/#multi-level-subcommands","title":"Multi-level subcommands","text":"<p>To add a subcommand to a parent command, separate their names with two underscores <code>__</code>. For example:</p> <ul> <li><code>s3__ls</code> \u2192 <code>s3 ls</code></li> <li><code>ec2__start_instances</code> \u2192 <code>ec2 start-instances</code></li> </ul> <p>Continuing this example:</p> [source] <pre><code>import arguably\n\n@arguably.command\ndef ec2__start_instances(*instances):\n\"\"\"\n    start instances\n    Args:\n        *instances: {instance}s to start\n    \"\"\"\n    for inst in instances:\n        print(f\"Starting {inst}\")\n\n@arguably.command\ndef ec2__stop_instances(*instances):\n\"\"\"\n    stop instances\n    Args:\n        *instances: {instance}s to stop\n    \"\"\"\n    for inst in instances:\n        print(f\"Stopping {inst}\")\n\n@arguably.command\ndef s3__ls(path=\"/\"):\n\"\"\"\n    list objects\n    Args:\n        path: path to list under\n    \"\"\"\n    print(f\"Listing objects under {path}\")\n\n@arguably.command\ndef s3__cp(src, dst):\n\"\"\"\n    copy objects\n    Args:\n        src: source object\n        dst: destination path\n    \"\"\"\n    print(f\"Copy {src} to {dst}\")\n\nif __name__ == \"__main__\":\n    arguably.run()\n</code></pre> <p><pre><code>user@machine:~$ python3 aws-1.py -h\nusage: aws-1.py [-h] command ...\n\npositional arguments:\n  command\n    ec2\n    s3\n\noptions:\n  -h, --help  show this help message and exit\n</code></pre> <pre><code>user@machine:~$ python3 aws-1.py s3 -h\nusage: aws-1.py s3 [-h] command ...\n\npositional arguments:\n  command\n    ls        list objects\n    cp        copy objects\n\noptions:\n  -h, --help  show this help message and exit\n</code></pre> <pre><code>user@machine:~$ python3 aws-1.py s3 ls -h\nusage: aws-1.py s3 ls [-h] [path]\n\nlist objects\n\npositional arguments:\n  path        path to list under (type: str, default: /)\n\noptions:\n  -h, --help  show this help message and exit\n</code></pre> <pre><code>user@machine:~$ python3 aws-1.py s3 ls /foo/bar\nListing objects under /foo/bar\n</code></pre></p>"},{"location":"tutorial/subcommands/#hierarchy","title":"Hierarchy","text":"<p>You may have noticed that <code>ec2</code> and <code>s3</code> had no description. This is because they are automatically created stubs. We can define them ourselves and attach arguments to them:</p> [source] <pre><code>@arguably.command\ndef s3(*, bucket):\n\"\"\"\n    s3 commands\n    Args:\n        bucket: the bucket to use\n    \"\"\"\n    print(f\"Using bucket: {bucket}\")\n</code></pre> <p><pre><code>user@machine:~$ python3 aws-2.py s3 -h\nusage: aws-2.py s3 [-h] [--bucket BUCKET] command ...\n\ns3 commands\n\npositional arguments:\n  command\n    ls             list objects\n    cp             copy objects\n\noptions:\n  -h, --help       show this help message and exit\n  --bucket BUCKET  the bucket to use (type: str)\n</code></pre> <pre><code>user@machine:~$ python3 aws-2.py s3 --bucket mybucket ls\nUsing bucket: mybucket\nListing objects under /\n</code></pre></p> <p>As you can see, <code>def s3(*, bucket)</code> was called first and printed the bucket name to use. After that, <code>def s3__ls(path=\"/\")</code> was invoked. This is because all ancestors are invoked before the target command is invoked. For a more complex example:</p> [source] <pre><code>import arguably\n\n@arguably.command\ndef first():\n    print(\"first\")\n\n@arguably.command\ndef first__second():\n    print(\"second\")\n\n@arguably.command\ndef first__second__third():\n    print(\"third\")\n\nif __name__ == \"__main__\":\n    arguably.run(always_subcommand=True)\n</code></pre> <pre><code>user@machine:~$ python3 nested-1.py first second third\nfirst\nsecond\nthird\n</code></pre>"},{"location":"tutorial/subcommands/#the-__root__-function","title":"The <code>__root__</code> function","text":"<p>If a function named <code>__root__</code> is marked with <code>@arguably.command</code>, it always appears as the highest ancestor for commands in the script. This allows global options and actions to be placed at the root of the script.</p> [source] <pre><code>import arguably\n\n@arguably.command\ndef __root__():\n    print(\"__root__\")\n\n@arguably.command\ndef hi():\n    print(\"hi\")\n\n@arguably.command\ndef bye():\n    print(\"bye\")\n\nif __name__ == \"__main__\":\n    arguably.run()\n</code></pre> <pre><code>user@machine:~$ python3 root-1.py hi\n__root__\nhi\n</code></pre>"},{"location":"tutorial/subcommands/#checking-arguablyis_target","title":"Checking <code>arguably.is_target()</code>","text":"<p>Sometimes you'll want to allow a command in the heirarchy to process its input arguments, but bail if it wasn't the target. For that, you can use <code>arguably.is_target()</code>. This returns <code>False</code> if the currently-executing function was called as an ancestor of the target command, and <code>True</code> every other time.</p> [source] <pre><code>import arguably\n\n@arguably.command\ndef __root__(*, config_file=None):\n    print(f\"Using config {config_file}\")\n    if not arguably.is_target():\n        return\n    print(\"__root__ is the target!\")\n\n@arguably.command\ndef hi():\n    print(\"hi is the target!\")\n\n@arguably.command\ndef bye():\n    print(\"bye is the target!\")\n\nif __name__ == \"__main__\":\n    arguably.run()\n</code></pre> <p><pre><code>user@machine:~$ python3 root-2.py --config-file foo.yml\nUsing config foo.yml\n__root__ is the target!\n</code></pre> <pre><code>user@machine:~$ python3 root-2.py --config-file foo.yml hi\nUsing config foo.yml\nhi is the target!\n</code></pre></p>"},{"location":"tutorial/type-hints/","title":"Type hints","text":""},{"location":"tutorial/type-hints/#introduction","title":"Introduction","text":"<p><code>arguably</code> uses type hints to convert CLI input from strings to the type needed by your function.</p> [source] <p><pre><code>import arguably\nfrom pathlib import Path\n\n@arguably.command\ndef basic(name: str, age: int, percent: float):\n\"\"\"all basic types like str, int, float, etc are supported\"\"\"\n    print(f\"{name=}\", f\"{age=}\", f\"{percent=}\")\n</code></pre> <pre><code>user@machine:~$ python3 type-hint.py basic Monty 42 33.3\nname='Monty' age=42 percent=33.3\n</code></pre> <pre><code>@arguably.command\ndef tuple_(value: tuple[str, int, float]):\n\"\"\"tuples can contain any supported type that isn't a list or tuple\"\"\"\n    print(f\"{value=}\")\n</code></pre> <pre><code>user@machine:~$ python3 type-hint.py tuple foo,1,3.14\nvalue=('foo', 1, 3.14)\n</code></pre> <pre><code>class UserType:\n    def __init__(self, val: str):\n        self.val = int(val)\n    def __repr__(self):\n        return f\"{type(self).__name__}(val={self.val})\"\n\n@arguably.command\ndef any_type(value: UserType, path: Path):\n\"\"\"any type that can be initialized from a string is supported\"\"\"\n    print(f\"{value=}\", f\"{path=}\")\n</code></pre> <pre><code>user@machine:~$ python3 type-hint.py any-type 123 .\nvalue=UserType(val=123) path=PosixPath('.')\n</code></pre> <pre><code>@arguably.command\ndef list_(files: list[Path], *, nums: list[int]):\n\"\"\"lists are supported. if they appear as an option\n    (like `coord` does), they can be specified multiple times\"\"\"\n    print(f\"{files=}\", f\"{nums=}\")\n</code></pre> <pre><code>user@machine:~$ python3 type-hint.py list foo.txt,bar.exe --nums 1 --nums 2,3\nfiles=[PosixPath('foo.txt'), PosixPath('bar.exe')] nums=[1, 2, 3]\n</code></pre> <pre><code>if __name__ == \"__main__\":\n    arguably.run()\n</code></pre></p>"},{"location":"tutorial/type-hints/#allowed-types","title":"Allowed types","text":""},{"location":"tutorial/type-hints/#normal-types","title":"\"Normal\" types","text":"<p>Any type that can be constructed by passing in a single string value is allowed. This includes:</p> <ul> <li>Basic built-in types like <code>str</code>, <code>int</code>, <code>float</code>, <code>bool</code></li> <li>Other built-ins like <code>pathlib.Path</code></li> <li>Any user-defined classes that also have this kind of constructor</li> </ul> <pre><code>@dataclass\nclass GoodClass1:\n\"\"\"Example of a user-defined class that can be used\"\"\"\n    name: str\n\n@dataclass\nclass BadClass1:\n\"\"\"NOT USABLE: This class won't work, since it should take in an integer\"\"\"\n    age: int\n\n@dataclass\nclass BadClass2:\n\"\"\"NOT USABLE: This class won't work, since it takes in multiple arguments\"\"\"\n    first_name: str\n    last_name: str\n\nclass GoodClass2:\n\"\"\"Example of another user-defined class that can be used\"\"\"\n    def __init__(self, value: str | int):\n        if isinstance(value, str):\n            value = int(str)\n        self._int_value = value\n</code></pre>"},{"location":"tutorial/type-hints/#unions-with-none","title":"Unions with <code>None</code>","text":"<p>Any union with <code>None</code> at the outermost level is ignored:</p> <ul> <li><code>Optional[int]</code> will be parsed as <code>int</code></li> <li><code>Tuple[str, int, float] | None</code> will be parsed as <code>Tuple[str, int, float]</code></li> <li><code>Tuple[Optional[str], int, float] | None</code> is not allowed - the first element can be either a <code>str</code> or <code>None</code>, which isn't possible to unambiguously parse.</li> </ul>"},{"location":"tutorial/type-hints/#tuples","title":"Tuples","text":"<p>Tuples are handled as comma-separated values. If you need to put a comma in a value itself, you can wrap it in quotes.</p> <ul> <li><code>tuple[int, int, int]</code> would take in <code>1,2,3</code></li> <li><code>tuple[int, float, str]</code> would take in <code>1,3.14,etc</code></li> <li><code>tuple[int, ...]</code> - would not work, as flexible-length tuples are not allowed (though this may change in the future)</li> <li><code>tuple[str, str]</code> would take in <code>'abc,\"d,e,f\"'</code>, which would become <code>(\"abc\", \"d,e,f\")</code></li> </ul> <p>Quote double-wrapping</p> <p>To escape a comma, the whole argument must be wrapped in quotes - this is necessary to prevent your shell from parsing away the inner pair of quotes. Please discuss in #7 if you have input on a better way of doing this.</p>"},{"location":"tutorial/type-hints/#lists","title":"Lists","text":"<p>Lists are comma-separated, like <code>tuples</code>. However, if a list appears as an <code>--option</code>, it can be specified multiple times.</p> <ul> <li><code>list[int]</code> would take in <code>1,2,3,4</code></li> <li><code>def foo(*, bar: list[int])</code> would take in <code>--bar 1 --bar 2 --bar 3,4</code></li> </ul>"},{"location":"tutorial/type-hints/#enumenum","title":"<code>enum.Enum</code>","text":"<p>Enums allow member names to be used as input. No other value is accepted.</p> <p>Enum names are normalized the same way as function names:</p> <ul> <li>Converted to lowercase</li> <li><code>_leading</code> and <code>trailing__</code> underscores <code>_</code> are stripped</li> <li>Underscores <code>between_words</code> are converted to dashes: <code>between-words</code></li> </ul> [source] <pre><code>import arguably\nimport enum\n\nclass Direction(enum.Enum):\n    UP = (0, 1)\n    DOWN = (0, -1)\n    LEFT = (-1, 0)\n    RIGHT = (1, 0)\n\n@arguably.command\ndef move(start: tuple[int, int], direction: Direction):\n    end = start + direction.value\n    print(f\"{start=}\", f\"{direction}\", f\"{end=}\")\n\nif __name__ == \"__main__\":\n    arguably.run()\n</code></pre> <p><pre><code>user@machine:~$ python3 enum-1.py 100,100 diagonally\nusage: enum-1.py [-h] start,start {up,down,left,right}\nenum-1.py: error: argument direction: invalid choice: 'diagonally' (choose from 'up', 'down', 'left', 'right')\n</code></pre> <pre><code>user@machine:~$ python3 enum-1.py 100,100 down\nstart=(100, 100) Direction.DOWN end=(100, 99)\n</code></pre></p>"},{"location":"tutorial/type-hints/#enumflag","title":"<code>enum.Flag</code>","text":"<p>Flag values never appear directly. Instead, each member always appears as an <code>--option</code>. The docstring for <code>enum.Flag</code> values is parsed as well, meaning you can create help messages for each entry and specify a shorthand through <code>[-x]</code>.</p> <p>Flag names are processed the same way as <code>enum.Enum</code> names.</p> [source] <p><pre><code>import arguably\nimport enum\nfrom pathlib import Path\n\nclass Permissions(enum.Flag):\n\"\"\"\n    Permission flags\n\n    Attributes:\n        READ: [-r] allows for reads\n        WRITE: [-w] allows for writes\n        EXECUTE: [-x] allows for execution\n    \"\"\"\n\n    READ = 4\n    WRITE = 2\n    EXECUTE = 1\n\nclass PermissionsAlt(enum.Flag):\n\"\"\"Annotations can also appear like this\"\"\"\n\n    READ = 4\n\"\"\"[-r] allows for reads\"\"\"\n    WRITE = 2\n\"\"\"[-w] allows for writes\"\"\"\n    EXECUTE = 1\n\"\"\"[-x] allows for execution\"\"\"\n\n@arguably.command\ndef chmod(file: Path, *, flags: Permissions = Permissions(0)):\n\"\"\"\n    change file permissions\n\n    Args:\n        file: the file to modify\n        flags: permission flags\n    \"\"\"\n    print(f\"{file=}\", f\"{flags=}\")\n\nif __name__ == \"__main__\":\n    arguably.run()\n</code></pre> <pre><code>user@machine:~$ python3 flag.py -h\nusage: flag.py [-h] [-r] [-w] [-x] file\n\nchange file permissions\n\npositional arguments:\n  file           the file to modify (type: Path)\n\noptions:\n  -h, --help     show this help message and exit\n  -r, --read     allows for reads\n  -w, --write    allows for writes\n  -x, --execute  allows for execution\n</code></pre> <pre><code>user@machine:~$ python3 flag.py foo.txt -rwx\nfile=PosixPath('foo.txt') flags=&lt;Permissions.READ|WRITE|EXECUTE: 7&gt;\n</code></pre></p>"},{"location":"tutorial/type-hints/#special-behaviors","title":"Special behaviors","text":"<p>There are a number of special behaviors you can attach to a parameter. These utilize the ability to attach metadata to a type using <code>typing.Annotated[]</code>:</p> <pre><code>def foo(\n    param: Annotated[&lt;param_type&gt;, arguably.arg.*()]\n):\n</code></pre> <ul> <li><code>arguably.arg.required()</code> requires <code>list[]</code> and <code>*args</code> params to not be empty, or marks an <code>--option</code> as required.</li> <li><code>arguably.arg.count()</code> counts the number of times an option appears: <code>-vvvv</code> gives <code>4</code>.</li> <li><code>arguably.arg.choices(*choices)</code> restricts inputs to <code>choices</code></li> <li><code>arguably.arg.missing(omit_value)</code> <code>--option foo</code> yields <code>foo</code>, but this allows the value to be omitted: just <code>--option</code> will use the given <code>omit_value</code>.</li> <li><code>arguably.arg.handler(func)</code> skips all the argument processing <code>arguably</code> does and just calls <code>func</code></li> <li><code>arguably.arg.builder()</code> treats the input as instructions on how to build a class</li> </ul>"},{"location":"tutorial/type-hints/#example","title":"Example","text":"<p>Here's an example of each being used. This is all the same script, but results are shown after each example.</p>"},{"location":"tutorial/type-hints/#arguablyargrequired","title":"<code>arguably.arg.required</code>","text":"[source] <pre><code>from pathlib import Path\n\nimport arguably\nfrom dataclasses import dataclass\nfrom typing import Annotated\n\n@arguably.command\ndef email(\n    from_: str,\n    *to: Annotated[str, arguably.arg.required()]\n):\n    print(f\"{from_=}\", f\"{to=}\")\n</code></pre> <p><pre><code>user@machine:~$ python3 annotated.py email example@google.com\nusage: annotated.py email [-h] from to [to ...]\nannotated.py email: error: the following arguments are required: to\n</code></pre> <pre><code>user@machine:~$ python3 annotated.py email foo@example.com monty@python.org shrubbery-interest@example.com\nfrom_='foo@example.com' to=('monty@python.org', 'shrubbery-interest@example.com')\n</code></pre></p>"},{"location":"tutorial/type-hints/#arguablyargcount","title":"<code>arguably.arg.count</code>","text":"<pre><code>@arguably.command\ndef process(\n    *,\n    verbose: Annotated[int, arguably.arg.count()],\n):\n\"\"\"\n    :param verbose: [-v] verbosity\n    \"\"\"\n    print(f\"{verbose=}\")\n</code></pre> <pre><code>user@machine:~$ python3 annotated.py process -vvvv\nverbose=4\n</code></pre>"},{"location":"tutorial/type-hints/#arguablyargchoices","title":"<code>arguably.arg.choices</code>","text":"<pre><code>@arguably.command\ndef move(\n    direction: Annotated[str, arguably.arg.choices(\"left\", \"right\", \"up\", \"down\")]\n):\n\"\"\"An enum is usually recommended for cases like this\"\"\"\n    print(f\"{direction=}\")\n</code></pre> <pre><code>user@machine:~$ python3 annotated.py move diagonally\nusage: annotated.py move [-h] {left,right,up,down}\nannotated.py move: error: argument direction: invalid choice: 'diagonally' (choose from 'left', 'right', 'up', 'down')\n</code></pre>"},{"location":"tutorial/type-hints/#arguablyargmissing","title":"<code>arguably.arg.missing</code>","text":"<pre><code>@arguably.command\ndef do_something(\n    *,\n    log: Annotated[Path | None, arguably.arg.missing(\"~/.log.txt\")] = None\n):\n    print(f\"{log=}\")\n</code></pre> <p><pre><code>user@machine:~$ python3 annotated.py do-something\nlog=None\n</code></pre> <pre><code>user@machine:~$ python3 annotated.py do-something --log\nlog=PosixPath('~/.log.txt')\n</code></pre> <pre><code>user@machine:~$ python3 annotated.py do-something --log here.log\nlog=PosixPath('here.log')\n</code></pre></p>"},{"location":"tutorial/type-hints/#arguablyarghandler","title":"<code>arguably.arg.handler</code>","text":"<pre><code>@arguably.command\ndef handle_it(\n    version: Annotated[int, arguably.arg.handler(lambda s: int(s.split(\"-\")[-1]))] = None\n):\n    print(f\"{version=}\")\n</code></pre> <pre><code>user@machine:~$ python3 annotated.py handle-it python-3\nversion=3\n</code></pre>"},{"location":"tutorial/type-hints/#arguablyargbuilder","title":"<code>arguably.arg.builder</code>","text":"<pre><code>class Nic: ...\n\n@arguably.subtype(alias=\"tap\")\n@dataclass\nclass TapNic(Nic):\n    model: str\n\n@arguably.subtype(alias=\"user\")\n@dataclass\nclass UserNic(Nic):\n    hostfwd: str\n\n@arguably.command\ndef builder(\n    *,\n    nic: Annotated[list[Nic], arguably.arg.builder()]\n):\n    print(f\"{nic=}\")\n</code></pre> <pre><code>user@machine:~$ python3 annotated.py builder --nic tap,model=e1000 --nic user,hostfwd=tcp::10022-:22\nnic=[TapNic(model='e1000'), UserNic(hostfwd='tcp::10022-:22')]\n</code></pre> <pre><code>if __name__ == \"__main__\":\n    arguably.run()\n</code></pre>"}]}